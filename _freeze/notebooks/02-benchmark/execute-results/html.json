{
  "hash": "d956ad44d585e79412c076453fc2fb2f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Benchmarking American Put option pricing algorithms\"\nauthor: \"Nelson Areal\"\ndate: 2025-12-12\nformat: \n  html:\n    toc: true\n    toc-title: \"Contents\"\n    toc-depth: 4\n    number-sections: true\n    number-depth: 4\n    embed-resources: true\n---\n\nLoad the libraries and source the functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(bench)\nlibrary(furrr)\nlibrary(Rcpp)\nlibrary(JuliaCall)\nlibrary(torch)\nlibrary(here)\nlibrary(apopt) # Our package with pre-compiled Rcpp code\n\nsource(here(\"R\", \"ap_naive.R\"))\nsource(here(\"R\", \"ap_v1.R\"))\nsource(here(\"R\", \"ap_v2.R\"))\nsource(here(\"R\", \"ap_v3.R\"))\n# For comparison, we still source the Rcpp implementation without the package\nRcpp::sourceCpp(here(\"R\", \"ap_v3_rcpp.cpp\"))\nsource(here(\"R\", \"ap_v3_rcpp.R\"))\nsource(here(\"R\", \"ap_v3_rcpp_par.R\"))\nsource(here(\"R\", \"ap_v3_julia.R\"))\nsource(here(\"R\", \"ap_v3_torch.R\"))\n```\n:::\n\n\n\n# R implementation\n\n## Benchmark single option pricing with different R implementations\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns <- 40\nk <- 40\nv <- 0.30\nr <- 0.08\ntt <- 0.25\nd <- 0\nnstep <- 1000\n\nbench_result_one_option_r <- bench::mark(\n  ap_naive(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v1(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v2(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v3(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  min_iterations = 10L\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n```\n\n\n:::\n\n```{.r .cell-code}\nbench_result_one_option_r\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 6\n  expression                             min median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr>                           <bch> <bch:>     <dbl> <bch:byt>    <dbl>\n1 ap_naive(S0 = s, K = k, r = r, q = … 212ms  224ms      4.13    23.2MB     14.1\n2 ap_v1(S0 = s, K = k, r = r, q = d, … 152ms  154ms      6.18   276.2KB     20.4\n3 ap_v2(S0 = s, K = k, r = r, q = d, … 152ms  155ms      6.45   263.2KB     20.6\n4 ap_v3(S0 = s, K = k, r = r, q = d, … 151ms  152ms      6.55   760.4KB     21.6\n```\n\n\n:::\n:::\n\n\n\n## Compute option values for all options in the sample\n\nRead the option parameters sample:\n\n::: {.cell}\n\n```{.r .cell-code}\noption_parameters <- readRDS(here(\"data\", \"processed\", \"option_parameters.rds\"))\n```\n:::\n\n\nComputation time for calculating the option values for all 2500 options in our sample using the naive R implementation:\n\n::: {.cell}\n\n```{.r .cell-code}\nr_naive_time_all_options <- bench::system_time({\n  option_values_naive <- option_parameters |>\n    mutate(\n      option_value = pmap_dbl(\n        list(\n          S0 = asset_price,\n          K = exercise_price,\n          r = riskless_rate,\n          q = dividend_rate,\n          tt = time_to_maturity,\n          sigma = volatility,\n          steps = nstep\n        ),\n        ap_naive,\n        .progress = FALSE\n      )\n    )\n})\n\nr_naive_time_all_options\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nprocess    real \n  10.2m   10.1m \n```\n\n\n:::\n:::\n\n\nAnd using the most efficient R implementation (version 3):\n\n::: {.cell}\n\n```{.r .cell-code}\nr_v3_time_all_options <- bench::system_time({\n  option_values_v3 <- option_parameters |>\n    mutate(\n      option_value = pmap_dbl(\n        list(\n          S0 = asset_price,\n          K = exercise_price,\n          r = riskless_rate,\n          q = dividend_rate,\n          tt = time_to_maturity,\n          sigma = volatility,\n          steps = nstep\n        ),\n        ap_v3,\n        .progress = FALSE\n      )\n    )\n})\n\nr_v3_time_all_options\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nprocess    real \n  6.72m   6.62m \n```\n\n\n:::\n:::\n\n\n\n## Parallel implementation\n\nLet's create new versions of the functions to capture any errors. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nap_naive_safe <- safely(ap_naive)\nap_v1_safe <- safely(ap_v1)\nap_v2_safe <- safely(ap_v2)\nap_v3_safe <- safely(ap_v3)\n```\n:::\n\n\nWe can easily parellize the results using the `furrr` package:\n\n::: {.cell}\n\n```{.r .cell-code}\nplan(multisession, workers = 10)\nr_v3_par_time_all_options <- bench::system_time({\n  option_values_v3_par <- option_parameters |>\n    mutate(\n      option_value = future_pmap(\n        list(\n          S0 = asset_price,\n          K = exercise_price,\n          r = riskless_rate,\n          q = dividend_rate,\n          tt = time_to_maturity,\n          sigma = volatility,\n          steps = nstep\n        ),\n        ap_v3_safe,\n        .progress = FALSE\n      )\n    ) |>\n    unnest_wider(option_value, names_sep = \"_\")\n})\nr_v3_par_time_all_options\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nprocess    real \n  1.31s  48.97s \n```\n\n\n:::\n\n```{.r .cell-code}\nplan(sequential)\n\nstopifnot(all(is.na(option_values_v3_par$option_value_error)))\n```\n:::\n\n\nWe can do the same for version 2 of the algorithm:\n\n::: {.cell}\n\n```{.r .cell-code}\nplan(multisession, workers = 10)\nr_v2_par_time_all_options <- bench::system_time({\n  option_values_v2_par <- option_parameters |>\n    mutate(\n      option_value = future_pmap(\n        list(\n          S0 = asset_price,\n          K = exercise_price,\n          r = riskless_rate,\n          q = dividend_rate,\n          tt = time_to_maturity,\n          sigma = volatility,\n          steps = nstep\n        ),\n        ap_v2_safe,\n        .progress = FALSE\n      )\n    ) |>\n    unnest_wider(option_value, names_sep = \"_\")\n})\nr_v2_par_time_all_options\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nprocess    real \n  1.25s  48.99s \n```\n\n\n:::\n\n```{.r .cell-code}\nplan(sequential)\n\nstopifnot(all(is.na(option_values_v2_par$option_value_error)))\n```\n:::\n\n\nWe can do the same for version 1 of the algorithm:\n\n::: {.cell}\n\n```{.r .cell-code}\nplan(multisession, workers = 10)\nr_v1_par_time_all_options <- bench::system_time({\n  option_values_v1_par <- option_parameters |>\n    mutate(\n      option_value = future_pmap(\n        list(\n          S0 = asset_price,\n          K = exercise_price,\n          r = riskless_rate,\n          q = dividend_rate,\n          tt = time_to_maturity,\n          sigma = volatility,\n          steps = nstep\n        ),\n        ap_v1_safe,\n        .progress = FALSE\n      )\n    ) |>\n    unnest_wider(option_value, names_sep = \"_\")\n})\nr_v1_par_time_all_options\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nprocess    real \n  1.26s  49.71s \n```\n\n\n:::\n\n```{.r .cell-code}\nplan(sequential)\n\nstopifnot(all(is.na(option_values_v1_par$option_value_error)))\n```\n:::\n\n\nAnd finally, we can do the same for the naive implementation of the algorithm:\n\n::: {.cell}\n\n```{.r .cell-code}\nplan(multisession, workers = 10)\nr_naive_par_time_all_options <- bench::system_time({\n  option_values_naive_par <- option_parameters |>\n    mutate(\n      option_value = future_pmap(\n        list(\n          S0 = asset_price,\n          K = exercise_price,\n          r = riskless_rate,\n          q = dividend_rate,\n          tt = time_to_maturity,\n          sigma = volatility,\n          steps = nstep\n        ),\n        ap_naive_safe,\n        .progress = FALSE\n      )\n    ) |>\n    unnest_wider(option_value, names_sep = \"_\")\n})\nr_naive_par_time_all_options\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nprocess    real \n  1.69s   1.18m \n```\n\n\n:::\n\n```{.r .cell-code}\nplan(sequential)\n\nstopifnot(all(is.na(option_values_naive_par$option_value_error)))\n```\n:::\n\n\n\nThe results are identical across all implementations:\n\n::: {.cell}\n\n```{.r .cell-code}\nidentical(\n  option_values_naive_par,\n  option_values_v1_par\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nidentical(\n  option_values_v1_par,\n  option_values_v2_par\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nidentical(\n  option_values_v2_par,\n  option_values_v3_par\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n# Using Rcpp\n\nThe Rcpp package allows us to write C++ code that can be called from R, providing significant performance improvements for computationally intensive tasks like the binomial tree algorithm.\n\n## Single Option Benchmark\n\nLet's compare the performance of `ap_v3` (pure R) with `ap_v3_rcpp` (C++ core with R wrapper):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench_result_one_option_rcpp <- bench::mark(\n  ap_v3(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v3_rcpp(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  min_iterations = 10L\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n```\n\n\n:::\n\n```{.r .cell-code}\nbench_result_one_option_rcpp\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 6\n  expression                           min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr>                      <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 ap_v3(S0 = s, K = k, r = r, q … 156.69ms 159.58ms      6.25    7.87KB     23.1\n2 ap_v3_rcpp(S0 = s, K = k, r = …   7.95ms   7.98ms    125.    496.13KB      0  \n```\n\n\n:::\n:::\n\n\nVerify that both implementations produce identical results:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstopifnot(all.equal(\n  ap_v3(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v3_rcpp(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep)\n))\n```\n:::\n\n\n## Benchmark on full dataset\n\nNow let's test the Rcpp implementation on the full dataset of 2,500 options:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrcpp_v3_time_all_options <- bench::system_time({\n  option_values_rcpp <- option_parameters |>\n    mutate(\n      option_value = pmap_dbl(\n        list(\n          S0 = asset_price,\n          K = exercise_price,\n          r = riskless_rate,\n          q = dividend_rate,\n          tt = time_to_maturity,\n          sigma = volatility,\n          steps = nstep\n        ),\n        ap_v3_rcpp,\n        .progress = FALSE\n      )\n    )\n})\n\nrcpp_v3_time_all_options\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nprocess    real \n  20.5s   20.2s \n```\n\n\n:::\n:::\n\n\nVerify correctness - all implementations should produce identical results:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstopifnot(all.equal(\n  option_values_v3$option_value,\n  option_values_rcpp$option_value,\n  tolerance = 1e-15\n))\n```\n:::\n\n\nWe can also parallelize the Rcpp implementation using the parallel-safe wrapper.\nSince the Rcpp function creates an external pointer to another object in C++, we can only use it in R session where it was created. So we need to modify the R wrapper function to create the external pointer inside the function. This is what the `ap_v3_rcpp_par` is doing.\n\nWe first create a safe version of the Rcpp function:\n\n::: {.cell}\n\n```{.r .cell-code}\nap_v3_rcpp_par_safe <- safely(ap_v3_rcpp_par)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplan(multisession, workers = 10)\nrcpp_v3_par_time_all_options <- bench::system_time({\n  option_values_rcpp_par <- option_parameters |>\n    mutate(\n      option_value = future_pmap(\n        list(\n          S0 = asset_price,\n          K = exercise_price,\n          r = riskless_rate,\n          q = dividend_rate,\n          tt = time_to_maturity,\n          sigma = volatility,\n          steps = nstep\n        ),\n        ap_v3_rcpp_par_safe,\n        .progress = FALSE,\n        .options = furrr_options(seed = TRUE)\n      )\n    ) |>\n    unnest_wider(option_value, names_sep = \"_\")\n})\nrcpp_v3_par_time_all_options\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n process     real \n388.37ms    7.01s \n```\n\n\n:::\n\n```{.r .cell-code}\nplan(sequential)\n\nstopifnot(all(is.na(option_values_rcpp_par$option_value_error)))\n```\n:::\n\n\nVerify correctness of parallel implementation:\n\n::: {.cell}\n\n```{.r .cell-code}\nstopifnot(all.equal(\n  option_values_v3$option_value,\n  option_values_rcpp_par$option_value_result,\n  tolerance = 1e-15\n))\n```\n:::\n\n\n\n## Optimized Parallel Rcpp using a Package\n\nThe previous approach (`ap_v3_rcpp_par`) has overhead because each worker must compile the C++ code on-demand. The best solution is to create a proper R package with pre-compiled code.\n\nWe created the `apopt` package which includes:\n- Pre-compiled C++ code (no runtime compilation needed)\n- Proper package structure with DESCRIPTION, NAMESPACE\n- The `ap_v3_rcpp()` function exported and ready to use\n\nBenefits of the package approach:\n1. **No compilation overhead**: C++ code is compiled once during package installation\n2. **Works seamlessly in parallel**: Each worker loads the pre-compiled shared library\n3. **No external pointer issues**: The package's dynamic library is loaded in each worker's session\n4. **Reusable**: Can be easily shared and installed on other systems\n\nSince the `apopt` package exports the same `ap_v3_rcpp()` function, we can use it directly in parallel without any wrapper:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplan(multisession, workers = 10)\n\n# Benchmark using the apopt package\n# Workers load the pre-compiled package - no compilation overhead!\nrcpp_v3_par_time_all_options_pkg <- bench::system_time({\n  option_values_rcpp_par_pkg <- option_parameters |>\n    mutate(\n      option_value = future_pmap(\n        list(\n          S0 = asset_price,\n          K = exercise_price,\n          r = riskless_rate,\n          q = dividend_rate,\n          tt = time_to_maturity,\n          sigma = volatility,\n          steps = nstep\n        ),\n        safely(apopt::ap_v3_rcpp), # Using the package version\n        .progress = FALSE,\n        .options = furrr_options(seed = TRUE)\n      )\n    ) |>\n    unnest_wider(option_value, names_sep = \"_\")\n})\nrcpp_v3_par_time_all_options_pkg\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nprocess    real \n175.8ms    2.9s \n```\n\n\n:::\n\n```{.r .cell-code}\nplan(sequential)\n```\n:::\n\n\nVerify correctness:\n\n::: {.cell}\n\n```{.r .cell-code}\nstopifnot(all.equal(\n  option_values_v3$option_value,\n  option_values_rcpp_par_pkg$option_value_result,\n  tolerance = 1e-15\n))\n```\n:::\n\n\nCompare the three Rcpp parallel approaches:\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(\n  approach = c(\"On-demand per-call compilation\", \"Using pre-compiled package\"),\n  time = c(\n    as.numeric(rcpp_v3_par_time_all_options[\"real\"]),\n    as.numeric(rcpp_v3_par_time_all_options_pkg[\"real\"])\n  )\n) |>\n  mutate(\n    speedup = time[1] / time,\n    time_str = format(bench::as_bench_time(time))\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 4\n  approach                        time speedup time_str\n  <chr>                          <dbl>   <dbl> <chr>   \n1 On-demand per-call compilation  7.01    1    7.01s   \n2 Using pre-compiled package      2.90    2.42 2.9s    \n```\n\n\n:::\n:::\n\n\n\n# Using Julia\n\nWe can use [JuliaCall: an R package for seamless integration between R and Julia](https://joss.theoj.org/papers/10.21105/joss.01284) package to call Julia code from R.\n\nThe function `init_julia_ap` from te file `ap_v3_julia.R` initializes the Julia environment and loads the Julia implementation of the American put option pricing algorithm.\n\n::: {.cell}\n\n```{.r .cell-code}\ninit_julia_ap()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJulia version 1.11.5 at location /Users/nareal/.julia/juliaup/julia-1.11.5+0.aarch64.apple.darwin14/bin will be used.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading setup script for JuliaCall...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nFinish loading setup script for JuliaCall.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJulia initialized with 8 threads and ap_v3.jl loaded successfully\n```\n\n\n:::\n:::\n\n\nWe can now compare the performance of `ap_v3` (pure R) with `ap_v3_julia` (Julia core with R wrapper):\n\n## Single Option Benchmark\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench_result_one_option_julia <- bench::mark(\n  ap_v3(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v3_rcpp(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v3_julia(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  min_iterations = 10L\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n```\n\n\n:::\n\n```{.r .cell-code}\nbench_result_one_option_julia\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 6\n  expression                           min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr>                      <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 ap_v3(S0 = s, K = k, r = r, q …  155.7ms 157.82ms      6.35    7.87KB     24.1\n2 ap_v3_rcpp(S0 = s, K = k, r = …   7.95ms   7.98ms    125.      7.87KB      0  \n3 ap_v3_julia(S0 = s, K = k, r =…  10.32ms  10.36ms     95.7     4.26KB      0  \n```\n\n\n:::\n:::\n\n\nVerify that both implementations produce identical results:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstopifnot(all.equal(\n  ap_v3(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v3_julia(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep)\n))\n```\n:::\n\n\n\n## Benchmark on Full Dataset\n\nNow let's test the Rcpp implementation on the full dataset of 2,500 options:\n\n\n::: {.cell}\n\n```{.r .cell-code}\njulia_v3_time_all_options <- bench::system_time({\n  option_values_julia <- option_parameters |>\n    mutate(\n      option_value = pmap_dbl(\n        list(\n          S0 = asset_price,\n          K = exercise_price,\n          r = riskless_rate,\n          q = dividend_rate,\n          tt = time_to_maturity,\n          sigma = volatility,\n          steps = nstep\n        ),\n        ap_v3_julia,\n        .progress = FALSE\n      )\n    )\n})\n\njulia_v3_time_all_options\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nprocess    real \n  26.6s   26.2s \n```\n\n\n:::\n:::\n\n\nVerify correctness - all implementations should produce identical results:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstopifnot(all.equal(\n  option_values_v3$option_value,\n  option_values_julia$option_value,\n  tolerance = 1e-13\n))\n```\n:::\n\n\nWe can also parallelize the Julia implementation using the parallel-safe wrapper.\nSince the Julia function creates an external pointer to another object in Julia, we can only use it in R session where it was created. So we need to use the `ap_v3_julia_auto` function initializes Julia if necessary and calls the option valuation function in Julia.\n\nWe first create a safe version of this Julia function:\n\n::: {.cell}\n\n```{.r .cell-code}\nap_v3_julia_auto_safe <- safely(ap_v3_julia_auto)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplan(multisession, workers = 10)\njulia_v3_par_time_all_options <- bench::system_time({\n  option_values_julia_par <- option_parameters |>\n    mutate(\n      option_value = future_pmap(\n        list(\n          S0 = asset_price,\n          K = exercise_price,\n          r = riskless_rate,\n          q = dividend_rate,\n          tt = time_to_maturity,\n          sigma = volatility,\n          steps = nstep\n        ),\n        ap_v3_julia_auto_safe,\n        .progress = FALSE,\n        .options = furrr_options(seed = TRUE)\n      )\n    ) |>\n    unnest_wider(option_value, names_sep = \"_\")\n})\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJulia version 1.11.5 at location /Users/nareal/.julia/juliaup/julia-1.11.5+0.aarch64.apple.darwin14/bin will be used.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading setup script for JuliaCall...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nFinish loading setup script for JuliaCall.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nhere() starts at /Users/nareal/Documents/work/uminho/aulas/2025-2026/bp/bplim_workshop_2025\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJulia initialized with 8 threads and ap_v3.jl loaded successfully\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJulia version 1.11.5 at location /Users/nareal/.julia/juliaup/julia-1.11.5+0.aarch64.apple.darwin14/bin will be used.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading setup script for JuliaCall...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nFinish loading setup script for JuliaCall.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nhere() starts at /Users/nareal/Documents/work/uminho/aulas/2025-2026/bp/bplim_workshop_2025\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJulia initialized with 8 threads and ap_v3.jl loaded successfully\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJulia version 1.11.5 at location /Users/nareal/.julia/juliaup/julia-1.11.5+0.aarch64.apple.darwin14/bin will be used.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading setup script for JuliaCall...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nFinish loading setup script for JuliaCall.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nhere() starts at /Users/nareal/Documents/work/uminho/aulas/2025-2026/bp/bplim_workshop_2025\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJulia initialized with 8 threads and ap_v3.jl loaded successfully\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJulia version 1.11.5 at location /Users/nareal/.julia/juliaup/julia-1.11.5+0.aarch64.apple.darwin14/bin will be used.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading setup script for JuliaCall...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nFinish loading setup script for JuliaCall.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nhere() starts at /Users/nareal/Documents/work/uminho/aulas/2025-2026/bp/bplim_workshop_2025\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJulia initialized with 8 threads and ap_v3.jl loaded successfully\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJulia version 1.11.5 at location /Users/nareal/.julia/juliaup/julia-1.11.5+0.aarch64.apple.darwin14/bin will be used.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading setup script for JuliaCall...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nFinish loading setup script for JuliaCall.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nhere() starts at /Users/nareal/Documents/work/uminho/aulas/2025-2026/bp/bplim_workshop_2025\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJulia initialized with 8 threads and ap_v3.jl loaded successfully\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJulia version 1.11.5 at location /Users/nareal/.julia/juliaup/julia-1.11.5+0.aarch64.apple.darwin14/bin will be used.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading setup script for JuliaCall...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nFinish loading setup script for JuliaCall.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nhere() starts at /Users/nareal/Documents/work/uminho/aulas/2025-2026/bp/bplim_workshop_2025\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJulia initialized with 8 threads and ap_v3.jl loaded successfully\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJulia version 1.11.5 at location /Users/nareal/.julia/juliaup/julia-1.11.5+0.aarch64.apple.darwin14/bin will be used.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading setup script for JuliaCall...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nFinish loading setup script for JuliaCall.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nhere() starts at /Users/nareal/Documents/work/uminho/aulas/2025-2026/bp/bplim_workshop_2025\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJulia initialized with 8 threads and ap_v3.jl loaded successfully\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJulia version 1.11.5 at location /Users/nareal/.julia/juliaup/julia-1.11.5+0.aarch64.apple.darwin14/bin will be used.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading setup script for JuliaCall...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nFinish loading setup script for JuliaCall.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nhere() starts at /Users/nareal/Documents/work/uminho/aulas/2025-2026/bp/bplim_workshop_2025\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJulia initialized with 8 threads and ap_v3.jl loaded successfully\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJulia version 1.11.5 at location /Users/nareal/.julia/juliaup/julia-1.11.5+0.aarch64.apple.darwin14/bin will be used.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading setup script for JuliaCall...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nFinish loading setup script for JuliaCall.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nhere() starts at /Users/nareal/Documents/work/uminho/aulas/2025-2026/bp/bplim_workshop_2025\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJulia initialized with 8 threads and ap_v3.jl loaded successfully\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJulia version 1.11.5 at location /Users/nareal/.julia/juliaup/julia-1.11.5+0.aarch64.apple.darwin14/bin will be used.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading setup script for JuliaCall...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nFinish loading setup script for JuliaCall.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nhere() starts at /Users/nareal/Documents/work/uminho/aulas/2025-2026/bp/bplim_workshop_2025\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJulia initialized with 8 threads and ap_v3.jl loaded successfully\n```\n\n\n:::\n\n```{.r .cell-code}\njulia_v3_par_time_all_options\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nprocess    real \n670.8ms   11.7s \n```\n\n\n:::\n\n```{.r .cell-code}\nplan(sequential)\n\nstopifnot(all(is.na(option_values_julia_par$option_value_error)))\n```\n:::\n\n\nVerify correctness of parallel implementation:\n\n::: {.cell}\n\n```{.r .cell-code}\nstopifnot(all.equal(\n  option_values_v3$option_value,\n  option_values_julia_par$option_value_result,\n  tolerance = 1e-13\n))\n```\n:::\n\n\n\n## Batch Processing with Julia-side parallelization\n\nThe previous parallel approach has significant overhead because each R worker initializes its own Julia runtime. A much more efficient approach is to send all parameters to Julia at once and use Julia's native multi-threading.\n\nFirst, let's reinitialize Julia with a specific number of threads (we'll use 10 threads):\n\n::: {.cell}\n\n```{.r .cell-code}\n# Reinitialize Julia with 10 threads\ninit_julia_ap(num_threads = 10)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJulia initialized with 8 threads and ap_v3.jl loaded successfully\n```\n\n\n:::\n:::\n\n\nNow benchmark the batch processing approach:\n\n::: {.cell}\n\n```{.r .cell-code}\njulia_v3_batch_time_all_options <- bench::system_time({\n  option_values_julia_batch <- option_parameters |>\n    mutate(\n      option_value = ap_v3_julia_batch(\n        S0 = asset_price,\n        K = exercise_price,\n        r = riskless_rate,\n        q = dividend_rate,\n        tt = time_to_maturity,\n        sigma = volatility,\n        steps = nstep\n      )\n    )\n})\n\njulia_v3_batch_time_all_options\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nprocess    real \n 27.81s   3.54s \n```\n\n\n:::\n:::\n\n\nVerify correctness:\n\n::: {.cell}\n\n```{.r .cell-code}\nstopifnot(all.equal(\n  option_values_v3$option_value,\n  option_values_julia_batch$option_value,\n  tolerance = 1e-13\n))\n```\n:::\n\n\nThis batch approach should be significantly faster than the R-side parallel approach (`julia_v3_par_time_all_options`) because:\n- Single Julia runtime initialization (no overhead per worker)\n- One bulk data transfer instead of many small transfers\n- Julia's efficient native threading via `Threads.@threads`\n\n\n# Using torch\n\nThe torch package provides GPU acceleration for tensor operations. Our implementation processes multiple options in batches on the GPU, making it highly efficient for large-scale option pricing.\n\n## Single Option Benchmark\n\nFirst, let's verify that a single option (as a batch of 1) produces the correct result:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench_result_one_option_torch <- bench::mark(\n  ap_v3(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v3_rcpp(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v3_julia(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v3_torch(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  min_iterations = 10L,\n  check = FALSE\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n```\n\n\n:::\n\n```{.r .cell-code}\nbench_result_one_option_torch\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 6\n  expression                           min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr>                      <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 ap_v3(S0 = s, K = k, r = r, q … 162.01ms 168.62ms      5.95    7.87KB     23.8\n2 ap_v3_rcpp(S0 = s, K = k, r = …   7.96ms   8.23ms    121.      7.87KB      0  \n3 ap_v3_julia(S0 = s, K = k, r =…   10.3ms   10.6ms     93.2         0B      0  \n4 ap_v3_torch(S0 = s, K = k, r =… 515.32ms 614.36ms      1.68    1.04MB     11.9\n```\n\n\n:::\n:::\n\n\nVerify correctness:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstopifnot(all.equal(\n  ap_v3(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v3_torch(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  tolerance = 1e-4\n))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nMPS device detected. Using torch_float() (float32).\n```\n\n\n:::\n:::\n\n\nNote that on my mac the GPU uses 32-bit floats by default which limits precision, so the results are only equal up to 4 significant digits.\n\n\n## Benchmark on Full Dataset with Batching\n\nThe torch implementation is designed to process multiple options simultaneously on the GPU. We'll group our 2,500 options into batches and process each batch in a single GPU call.\n\nFirst, let's create a helper function to process batches:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprocess_torch_batches <- function(data, batch_size, nstep) {\n  # Add batch ID\n  data_with_batches <- data |>\n    mutate(batch_id = ceiling(row_number() / batch_size))\n\n  # Process each batch\n  results <- data_with_batches |>\n    group_by(batch_id) |>\n    nest() |>\n    mutate(\n      option_value = map(data, function(batch_data) {\n        ap_v3_torch(\n          S0 = batch_data$asset_price,\n          K = batch_data$exercise_price,\n          r = batch_data$riskless_rate,\n          q = batch_data$dividend_rate,\n          tt = batch_data$time_to_maturity,\n          sigma = batch_data$volatility,\n          steps = nstep\n        )\n      })\n    ) |>\n    unnest(c(data, option_value))\n\n  return(results)\n}\n```\n:::\n\n\nNow benchmark with different batch sizes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Batch size = 100 (25 batches)\ntorch_v3_time_batch_100 <- bench::system_time({\n  option_values_torch_100 <- process_torch_batches(\n    option_parameters,\n    batch_size = 100,\n    nstep = nstep\n  )\n})\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\n```\n\n\n:::\n\n```{.r .cell-code}\ntorch_v3_time_batch_100\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nprocess    real \n  33.6s   32.6s \n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Batch size = 500 (5 batches)\ntorch_v3_time_batch_500 <- bench::system_time({\n  option_values_torch_500 <- process_torch_batches(\n    option_parameters,\n    batch_size = 500,\n    nstep = nstep\n  )\n})\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\n```\n\n\n:::\n\n```{.r .cell-code}\ntorch_v3_time_batch_500\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nprocess    real \n  24.4s   24.1s \n```\n\n\n:::\n:::\n\n\nVerify correctness - all implementations should produce identical results:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstopifnot(all.equal(\n  option_values_v3_par$option_value_result,\n  option_values_torch_100$option_value,\n  tolerance = 1e-4\n))\n\n\nstopifnot(all.equal(\n  option_values_v3_par$option_value_result,\n  option_values_torch_500$option_value,\n  tolerance = 1e-4\n))\n```\n:::\n\n\nThey are only equal up to 4 significant digits due to differences in floating point arithmetic on the GPU. On my mac the GPU uses 32-bit floats by default which limits precision.\n\n\n# Saving all the benchmark times\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsave(\n  bench_result_one_option_r,\n  r_naive_time_all_options,\n  r_v3_time_all_options,\n  r_v3_par_time_all_options,\n  r_v2_par_time_all_options,\n  r_v1_par_time_all_options,\n  r_naive_par_time_all_options,\n  bench_result_one_option_rcpp,\n  rcpp_v3_time_all_options,\n  rcpp_v3_par_time_all_options,\n  rcpp_v3_par_time_all_options_pkg,\n  bench_result_one_option_julia,\n  julia_v3_time_all_options,\n  julia_v3_par_time_all_options,\n  julia_v3_batch_time_all_options,\n  bench_result_one_option_torch,\n  torch_v3_time_batch_100,\n  torch_v3_time_batch_500,\n  file = here(\"data\", \"processed\", \"benchmark_results.RData\")\n)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}