{
  "hash": "c55a6b4ecc8da057ebd5e345476f1b8c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Parallel and Cross-Language Computing\nsubtitle: A Hands-On Workshop for Empirical Researchers\nformat: \n  clean-revealjs:\n    logo: images/EEG_bw.png\n    slide-number: true\n    show-slide-number: all\n    controls: true\n    embed-resources: true\n    css:\n      - css/extra.css\nauthor:\n  - name: Nelson Areal\n    orcid: 0000-0002-1157-0178\n    email: nareal@eeg.uminho.pt\n    affiliations: NIPE/University of Minho\n  - name: Miguel Portela\n    orcid: 0000-0002-4721-2081\n    email: miguel.portela@eeg.uminho.pt\n    affiliations: NIPE/University of Minho/Banco de Portugal\ndate: last-modified\nfilters:\n  #- tachyons\n  - diagram\ndiagram:\n  engine:\n    tikz:\n      execpath: xelatex\n      header-includes:\n        - '\\usepackage{adjustbox}'\n        - '\\usetikzlibrary{matrix,positioning}'\n        - '\\tikzset{bullet/.style={circle,fill,inner sep=2pt}}'\n        - '\\renewcommand{\\familydefault}{\\sfdefault}'\n---\n\n\n::: {.cell}\n\n:::\n\n\n\n## Plan for the session \n\nDiscuss some strategies to optimize code performance:\n\n- Optimize the algorithm  \n- Use parallel computing  \n- Use a lower-level language (C++, Julia, etc.)  \n- Use the GPU  \n\nWe are going to illustrate these strategies using two examples.\n\n\n## Some initial thoughts on optimization\n\n> \"*Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered. We should forget about small efficiencies, say about 97% of the time: **premature optimization is the root of all evil.** [**Yet we should not pass up our opportunities in that critical 3%**]{.alert}.*\"\n\n[Knuth, D. E. (1974). Structured programming with go to statements. ACM Computing Surveys (CSUR), 6(4), 261-301.]{.small}\n\n\n## Ready made tools\n\nFor most data manipulation tasks, there are already great alternatives:\n\n- [Apache Arrow](https://arrow.apache.org/)\n- [Polars](https://pola.rs/)\n- [DuckDB](https://duckdb.org/)\n- [Apache Spark™](https://spark.apache.org/)\n\nThese tools are optimized for performance and can handle large datasets efficiently.\n\nThere is no need to reinvent the wheel.\n\n\n## How to identify bottlenecks?\n\nUse **profiling tools** to identify bottlenecks in your code, in R consider using the  [profvis](https://profvis.r-lib.org/) package.\n\nAnd then focus on optimizing the parts of the code that are most time-consuming.\n\nThe strategies we are going to discuss can be applied if the bottleneck is not yet programmed in an optimized way or in parallel.\n\n\n## Two illustrations\n\nWe are going to illustrate some of the strategies using two examples:\n\n- American option valuation\n- High-dimensional fixed effect models\n\n\n\n# Valuing an american option {background-color=\"#A1BC98\"}\n\n\n## Option valuation with binomial trees \n\nWe need the following parameters to value an option using a binomial tree:\n\n- Current underlying asset price: $S_0$\n- Strike price: $K$\n- Time to maturity: $T$ in years\n- Risk-free interest rate: $r$ continuously compounded\n- Dividend yield: $q$ continuously compounded\n- Volatility of the underlying asset: $\\sigma$\n- Number of time steps in the binomial tree: $N$\n- Type of option: Call or Put\n\nWe are going to assume an **American put option** for this example.\n\n\n## Option valuation with binomial trees\n\nOnce we have the parameters, we can proceed to build the binomial tree and value the option.\n\nWe will be using the CRR (Cox-Ross-Rubinstein) parameters:\n\n- $u = e^{\\sigma\\sqrt{\\Delta t}}$\n- $d = e^{-\\sigma\\sqrt{\\Delta t}}$\n- $\\Delta t = \\frac{T}{N}$\n- $p = \\frac{e^{(r - q) \\Delta t} - d}{u - d}$\n\n\n## Option valuation with binomial trees\n\nNow we need to follow these steps:\n\n1. Build the underlying asset price tree\n2. Calculate the option values at each node, starting from maturity and working backwards to the present.\n3. Determine the option price at the initial node.\n\n\n\n## Option valuation with binomial trees\n### Build the underlying asset price tree\n\n:::{.tc}\n```{.tikz}\n\\begin{tikzpicture}[>=stealth,sloped,font=\\sffamily,every node/.style={scale=4}]\n    \\matrix (tree) [%\n      matrix of nodes,\n      minimum size=1cm,\n      column sep=4cm,\n      row sep=1.5cm,nodes={text width=22em}\n          ]\n    {\n          &   &  {\\LARGE $S_0uu$} \\\\\n          & \\; &   \\\\\n     {\\LARGE $S_0$} &   &  {\\LARGE $S_0ud$} \\\\\n          & \\; &   \\\\\n          &   &  {\\LARGE $S_0dd$} \\\\\n    };\n    \\node[bullet,left=-8mm of tree-3-1.west](b-3-1){};\n    \\node[bullet,left=3.14mm of tree-2-2.west,label=above:{\\LARGE $S_0u$}](b-2-2){};\n    \\node[bullet,left=3.14mm of tree-4-2.west,label=above:{\\LARGE $S_0d$}](b-4-2){};\n    \\node[bullet,left=3.14mm of tree-1-3.west](b-1-3){};\n    \\node[bullet,left=3.14mm of tree-3-3.west](b-3-3){};\n    \\node[bullet,left=3.14mm of tree-5-3.west](b-5-3){};\n    \\draw[->] (b-3-1) -- (b-2-2);\n    \\draw[->] (b-2-2) -- (b-1-3);\n    \\draw[->] (b-2-2) -- (b-3-3);\n    \\draw[->] (b-3-1) -- (b-4-2);\n    \\draw[->] (b-4-2) -- (b-3-3);\n    \\draw[->] (b-4-2) -- (b-5-3);\n  \\end{tikzpicture}\n```\n:::\n\n\n\n## Option valuation with binomial trees \n### Calculating option values at maturity\n\n:::{.tc}\n```{.tikz}\n\\begin{tikzpicture}[>=stealth,sloped,font=\\sffamily,every node/.style={scale=4}]\n    \\matrix (tree) [%\n      matrix of nodes,\n      minimum size=1cm,\n      column sep=4cm,\n      row sep=1.5cm,nodes={text width=22em}\n          ]\n    {\n          &   &  {\\LARGE $S_0uu$ \\\\ {\\color{blue} $f_{uu} = max(K - S_0uu, 0)$}} \\\\\n          & \\; &   \\\\\n     {\\LARGE $S_0$} &   &  {\\LARGE $S_0ud$ \\\\ {\\color{blue} $f_{ud} = max(K - S_0ud, 0)$}}\\\\\n          & \\; &   \\\\\n          &   &  {\\LARGE $S_0dd$ \\\\ {\\color{blue} $f_{dd} = max(K - S_0dd, 0)$}}\\\\\n    };\n    \\node[bullet,left=-8mm of tree-3-1.west](b-3-1){};\n    \\node[bullet,left=3.14mm of tree-2-2.west,label=above:{\\LARGE $S_0u$}](b-2-2){};\n    \\node[bullet,left=3.14mm of tree-4-2.west,label=above:{\\LARGE $S_0d$}](b-4-2){};\n    \\node[bullet,left=3.14mm of tree-1-3.west](b-1-3){};\n    \\node[bullet,left=3.14mm of tree-3-3.west](b-3-3){};\n    \\node[bullet,left=3.14mm of tree-5-3.west](b-5-3){};\n    \\draw[->] (b-3-1) -- (b-2-2);\n    \\draw[->] (b-2-2) -- (b-1-3);\n    \\draw[->] (b-2-2) -- (b-3-3);\n    \\draw[->] (b-3-1) -- (b-4-2);\n    \\draw[->] (b-4-2) -- (b-3-3);\n    \\draw[->] (b-4-2) -- (b-5-3);\n  \\end{tikzpicture}\n```\n:::\n\n\n\n## Option valuation with binomial trees \n### Calculating option values at all previous nodes\n\n\n:::{.tc}\n```{.tikz}\n\\begin{tikzpicture}[>=stealth,sloped,font=\\sffamily,every node/.style={scale=4}]\n    \\matrix (tree) [%\n      matrix of nodes,\n      minimum size=1cm,\n      column sep=4cm,\n      row sep=1.5cm,nodes={text width=22em}\n          ]\n    {\n          &   &  {\\LARGE $S_0uu$ \\\\ {\\color{blue} $f_{uu} = max(K - S_0uu, 0)$}} \\\\\n          & {\\LARGE \\color{purple} \\\\[0.6cm] $f_{u} = max((p \\times f_{uu} + (1-p) \\times f_{ud}) \\times e^{-r\\Delta t}, K- S_0u)$} &   \\\\\n     {\\LARGE $S_0$} &   &  {\\LARGE $S_0ud$ \\\\ {\\color{blue} $f_{ud} = max(K - S_0ud, 0)$}}\\\\\n          & {\\LARGE \\color{purple} \\\\[0.6cm] $f_{d} = max((p \\times f_{ud} + (1-p) \\times f_{dd}) \\times e^{-r\\Delta t}, K- S_0d)$} &   \\\\\n          &   &  {\\LARGE $S_0dd$ \\\\ {\\color{blue} $f_{dd} = max(K - S_0dd, 0)$}}\\\\\n    };\n    \\node[bullet,left=-8mm of tree-3-1.west](b-3-1){};\n    \\node[bullet,left=3.14mm of tree-2-2.west,label=above:{\\LARGE $S_0u$}](b-2-2){};\n    \\node[bullet,left=3.14mm of tree-4-2.west,label=above:{\\LARGE $S_0d$}](b-4-2){};\n    \\node[bullet,left=3.14mm of tree-1-3.west](b-1-3){};\n    \\node[bullet,left=3.14mm of tree-3-3.west](b-3-3){};\n    \\node[bullet,left=3.14mm of tree-5-3.west](b-5-3){};\n    \\draw[->] (b-3-1) -- (b-2-2);\n    \\draw[->] (b-2-2) -- (b-1-3);\n    \\draw[->] (b-2-2) -- (b-3-3);\n    \\draw[->] (b-3-1) -- (b-4-2);\n    \\draw[->] (b-4-2) -- (b-3-3);\n    \\draw[->] (b-4-2) -- (b-5-3);\n  \\end{tikzpicture}\n```\n:::\n\n\n## Option valuation with binomial trees \n### Calculating option values at all previous nodes\n\n\n:::{.tc}\n```{.tikz}\n\\begin{tikzpicture}[>=stealth,sloped,font=\\sffamily,every node/.style={scale=4}]\n    \\matrix (tree) [%\n      matrix of nodes,\n      minimum size=1cm,\n      column sep=4cm,\n      row sep=1.5cm,nodes={text width=22em}\n          ]\n    {\n          &   &  {\\LARGE $S_0uu$ \\\\ {\\color{blue} $f_{uu} = max(K - S_0uu, 0)$}} \\\\\n          & {\\LARGE \\color{purple} \\\\[0.6cm] $f_{u} = max((p \\times f_{uu} + (1-p) \\times f_{ud}) \\times e^{-r\\Delta t}, K- S_0u)$} &   \\\\\n     {\\LARGE \\color{teal} $S_0 \\\\[0.2cm] f = max((p \\times f_{u} + (1-p) \\times f_{d}) \\times e^{-r\\Delta t}, K- S_0)$} &   &  {\\LARGE $S_0ud$ \\\\ {\\color{blue} $f_{ud} = max(K - S_0ud, 0)$}}\\\\\n          & {\\LARGE \\color{purple} \\\\[0.6cm] $f_{d} = max((p \\times f_{ud} + (1-p) \\times f_{dd}) \\times e^{-r\\Delta t}, K- S_0d)$} &   \\\\\n          &   &  {\\LARGE $S_0dd$ \\\\ {\\color{blue} $f_{dd} = max(K - S_0dd, 0)$}}\\\\\n    };\n    \\node[bullet,left=-8mm of tree-3-1.west](b-3-1){};\n    \\node[bullet,left=3.14mm of tree-2-2.west,label=above:{\\LARGE $S_0u$}](b-2-2){};\n    \\node[bullet,left=3.14mm of tree-4-2.west,label=above:{\\LARGE $S_0d$}](b-4-2){};\n    \\node[bullet,left=3.14mm of tree-1-3.west](b-1-3){};\n    \\node[bullet,left=3.14mm of tree-3-3.west](b-3-3){};\n    \\node[bullet,left=3.14mm of tree-5-3.west](b-5-3){};\n    \\draw[->] (b-3-1) -- (b-2-2);\n    \\draw[->] (b-2-2) -- (b-1-3);\n    \\draw[->] (b-2-2) -- (b-3-3);\n    \\draw[->] (b-3-1) -- (b-4-2);\n    \\draw[->] (b-4-2) -- (b-3-3);\n    \\draw[->] (b-4-2) -- (b-5-3);\n  \\end{tikzpicture}\n```\n:::\n\n[Binomial trees – Derivatives](https://derivatives.nelsonareal.net/chapter-4/ch-4.4-binomial_trees.html)\n\n\n# R implementation {background-color=\"#F1F3E0\"}\n\n## R implementation \n\n::: {.panel-tabset .Small}\n\n### Naive\n\n:::{.huge}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This function implements a bionomial tree algorithm for\n# valuing American put options using Cox-Ross-Rubinstein parameters.\n\nap_naive <- function(S0, K, r, q, tt, sigma, steps) {\n  # S0: Initial stock price\n  # K: Strike price\n  # r: Risk-free interest rate compounded continuously\n  # q: Dividend yield compounded continuously\n  # tt: Time to maturity in years\n  # sigma: Volatility of the underlying stock\n  # steps: Number of time steps in the binomial tree\n\n  dt <- tt / steps # time between steps\n  u <- exp(sigma * sqrt(dt)) # Up factor\n  d <- exp(-sigma * sqrt(dt)) # Down factor\n  p <- (exp((r - q) * dt) - d) / (u - d) # Risk-neutral probability\n\n  # Initialize matrices for asset prices and option values\n  # Rows represent nodes (i), columns represent time steps (j)\n  asset_prices <- matrix(NA, nrow = steps + 1, ncol = steps + 1)\n  option_values <- matrix(NA, nrow = steps + 1, ncol = steps + 1)\n\n  # Fill in asset prices for all nodes in the tree (lower triangular)\n  for (j in 1:(steps + 1)) {\n    for (i in (steps + 2 - j):(steps + 1)) {\n      asset_prices[i, j] <- S0 * u^(steps + 1 - i) * d^(i + j - steps - 2)\n    }\n  }\n\n  # Initialize option values at maturity (last column)\n  for (i in 1:(steps + 1)) {\n    option_values[i, steps + 1] <- max(K - asset_prices[i, steps + 1], 0)\n  }\n\n  # Backward induction to calculate option price at earlier nodes\n  # i - node, j - time step\n  for (j in steps:1) {\n    for (i in (steps + 2 - j):(steps + 1)) {\n      # Calculate continuation value\n      option_values[i, j] <-\n        (p * option_values[i - 1, j + 1] + (1 - p) * option_values[i, j + 1]) *\n        exp(-r * dt)\n\n      # Check for early exercise\n      intrinsic_value <- K - asset_prices[i, j]\n      option_values[i, j] <- max(option_values[i, j], intrinsic_value)\n    }\n  }\n\n  return(option_values[steps + 1, 1]) # Option price at the root node\n}\n```\n:::\n\n\n:::\n\n\n### v1 - Vectors \n\nVectors instead of matrices\n\n:::{.huge}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This function implements an optimized binomial tree algorithm for\n# valuing American put options using Cox-Ross-Rubinstein parameters.\n# Optimization:\n# Uses vectors instead of matrices and calculates asset prices on the fly.\n\nap_v1 <- function(S0, K, r, q, tt, sigma, steps) {\n  # S0: Initial stock price\n  # K: Strike price\n  # r: Risk-free interest rate compounded continuously\n  # q: Dividend yield compounded continuously\n  # tt: Time to maturity in years\n  # sigma: Volatility of the underlying stock\n  # steps: Number of time steps in the binomial tree\n\n  dt <- tt / steps # time between steps\n  u <- exp(sigma * sqrt(dt)) # Up factor\n  d <- exp(-sigma * sqrt(dt)) # Down factor\n  p <- (exp((r - q) * dt) - d) / (u - d) # Risk-neutral probability\n  disc <- exp(-r * dt) # Discount factor\n\n  # Initialize option values at maturity\n  # Vector size is steps + 1 (for nodes 0 to steps)\n  option_values <- numeric(steps + 1)\n\n  # Calculate option values at maturity\n  for (i in 1:(steps + 1)) {\n    # At maturity, node i has (steps + 1 - i) up moves and (i - 1) down moves\n    asset_price <- S0 * u^(steps + 1 - i) * d^(i - 1)\n    option_values[i] <- max(K - asset_price, 0)\n  }\n\n  # Backward induction to calculate option price at earlier nodes\n  for (j in steps:1) {\n    # At time step j, we have j nodes\n    for (i in 1:j) {\n      # Calculate continuation value\n      option_values[i] <- (p *\n        option_values[i] +\n        (1 - p) * option_values[i + 1]) *\n        disc\n\n      # Calculate asset price for early exercise check\n      # At time step j-1, node i has (j - i) up moves and (i - 1) down moves\n      asset_price <- S0 * u^(j - i) * d^(i - 1)\n\n      # Check for early exercise\n      intrinsic_value <- K - asset_price\n      option_values[i] <- max(option_values[i], intrinsic_value)\n    }\n  }\n\n  return(option_values[1]) # Option price at the root node\n}\n```\n:::\n\n\n:::\n\n\n### v2 - Vectors\n\nVectors instead of matrices without the first loop\n\n:::{.huge}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This function implements an optimized binomial tree algorithm for\n# valuing American put options using Cox-Ross-Rubinstein parameters.\n# Optimization:\n# Uses vectors instead of matrices and calculates asset prices on the fly\n# and removes one loop in relation to ap_v1.\n\nap_v2 <- function(S0, K, r, q, tt, sigma, steps) {\n  # S0: Initial stock price\n  # K: Strike price\n  # r: Risk-free interest rate compounded continuously\n  # q: Dividend yield compounded continuously\n  # tt: Time to maturity in years\n  # sigma: Volatility of the underlying stock\n  # steps: Number of time steps in the binomial tree\n\n  dt <- tt / steps # time between steps\n  u <- exp(sigma * sqrt(dt)) # Up factor\n  d <- exp(-sigma * sqrt(dt)) # Down factor\n  p <- (exp((r - q) * dt) - d) / (u - d) # Risk-neutral probability\n  disc <- exp(-r * dt) # Discount factor\n\n  # Vector to store option values\n  option_values <- numeric(steps + 1)\n\n  # Backward induction from maturity to root\n  for (j in (steps + 1):1) {\n    num_nodes <- if (j == steps + 1) steps + 1 else j\n\n    for (i in 1:num_nodes) {\n      # Calculate asset price at this node\n      asset_price <- S0 * u^(j - i) * d^(i - 1)\n\n      if (j == steps + 1) {\n        # At maturity: option value is intrinsic value\n        option_values[i] <- max(K - asset_price, 0)\n      } else {\n        # Before maturity: calculate continuation value and check early exercise\n        continuation_value <- (p *\n          option_values[i] +\n          (1 - p) * option_values[i + 1]) *\n          disc\n        intrinsic_value <- K - asset_price\n        option_values[i] <- max(continuation_value, intrinsic_value)\n      }\n    }\n  }\n\n  return(option_values[1]) # Option price at the root node\n}\n```\n:::\n\n\n:::\n\n\n### v3 - Vectors\n\nSimilar to v2 but with defensive programming\n\n:::{.huge}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This function implements an optimized binomial tree algorithm for\n# valuing American put options using Cox-Ross-Rubinstein parameters.\n# In relation to ap_v2 includes defensive programming with input validation.\n\nap_v3 <- function(S0, K, r, q, tt, sigma, steps) {\n  # S0: Initial stock price\n  # K: Strike price\n  # r: Risk-free interest rate compounded continuously\n  # q: Dividend yield compounded continuously\n  # tt: Time to maturity in years\n  # sigma: Volatility of the underlying stock\n  # steps: Number of time steps in the binomial tree\n\n  # Input validation\n  # Check for missing arguments\n  if (\n    missing(S0) ||\n      missing(K) ||\n      missing(r) ||\n      missing(q) ||\n      missing(tt) ||\n      missing(sigma) ||\n      missing(steps)\n  ) {\n    stop(\"All arguments must be provided\")\n  }\n\n  # Check for NA or NULL values\n  if (\n    any(is.na(c(S0, K, r, q, tt, sigma, steps))) ||\n      any(is.null(c(S0, K, r, q, tt, sigma, steps)))\n  ) {\n    stop(\"Arguments cannot be NA or NULL\")\n  }\n\n  # Check that all inputs are numeric\n  if (\n    !is.numeric(S0) ||\n      !is.numeric(K) ||\n      !is.numeric(r) ||\n      !is.numeric(q) ||\n      !is.numeric(tt) ||\n      !is.numeric(sigma) ||\n      !is.numeric(steps)\n  ) {\n    stop(\"All arguments must be numeric\")\n  }\n\n  # Check that inputs are scalar (length 1)\n  if (\n    length(S0) != 1 ||\n      length(K) != 1 ||\n      length(r) != 1 ||\n      length(q) != 1 ||\n      length(tt) != 1 ||\n      length(sigma) != 1 ||\n      length(steps) != 1\n  ) {\n    stop(\"All arguments must be scalar values\")\n  }\n\n  # Validate parameter ranges\n  if (S0 <= 0) {\n    stop(\"Initial stock price (S0) must be positive\")\n  }\n\n  if (K <= 0) {\n    stop(\"Strike price (K) must be positive\")\n  }\n\n  if (tt <= 0) {\n    stop(\"Time to maturity (tt) must be positive\")\n  }\n\n  if (sigma <= 0) {\n    stop(\"Volatility (sigma) must be positive\")\n  }\n\n  if (q < 0) {\n    stop(\"Dividend yield (q) must be non-negative\")\n  }\n\n  if (steps < 1) {\n    stop(\"Number of steps must be at least 1\")\n  }\n\n  # Check that steps is an integer\n  if (steps != floor(steps)) {\n    stop(\"Number of steps must be an integer\")\n  }\n\n  # Calculate parameters\n  dt <- tt / steps # time between steps\n  u <- exp(sigma * sqrt(dt)) # Up factor\n  d <- exp(-sigma * sqrt(dt)) # Down factor\n  p <- (exp((r - q) * dt) - d) / (u - d) # Risk-neutral probability\n\n  # Validate risk-neutral probability (arbitrage-free condition)\n  if (p < 0 || p > 1) {\n    stop(sprintf(\n      \"Risk-neutral probability p=%.4f is outside [0,1]. Model parameters lead to arbitrage.\",\n      p\n    ))\n  }\n\n  disc <- exp(-r * dt) # Discount factor\n\n  # Vector to store option values\n  option_values <- numeric(steps + 1)\n\n  # Backward induction from maturity to root\n  for (j in (steps + 1):1) {\n    num_nodes <- if (j == steps + 1) steps + 1 else j\n\n    for (i in 1:num_nodes) {\n      # Calculate asset price at this node\n      asset_price <- S0 * u^(j - i) * d^(i - 1)\n\n      if (j == steps + 1) {\n        # At maturity: option value is intrinsic value\n        option_values[i] <- max(K - asset_price, 0)\n      } else {\n        # Before maturity: calculate continuation value and check early exercise\n        continuation_value <- (p *\n          option_values[i] +\n          (1 - p) * option_values[i + 1]) *\n          disc\n        intrinsic_value <- K - asset_price\n        option_values[i] <- max(continuation_value, intrinsic_value)\n      }\n    }\n  }\n\n  return(option_values[1]) # Option price at the root node\n}\n```\n:::\n\n\n:::\n\n:::\n\n## A naive implementation in R \n\nThere are other ways that the convergence can be improved:\n\n- Alternative parameters (e.g., Jarrow-Rudd, Tian, Leisen-Reimer)\n- Control variates\n- Extrapolation techniques (e.g., Richardson extrapolation)\n\nWe just want to focus on computational performance improvements.\n\n## Benchmarking the R implementations\n\nWith only one option:\n\n::: {.panel-tabset}\n\n### Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns <- 40\nk <- 40\nv <- 0.30\nr <- 0.08\ntt <- 0.25\nd <- 0\nnstep <- 1000\n\nbench_result_one_option_r <- bench::mark(\n  ap_naive(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v1(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v2(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v3(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  min_iterations = 10L\n)\n```\n:::\n\n\n### Results\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench_result_one_option_r\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 6\n  expression                             min median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr>                           <bch> <bch:>     <dbl> <bch:byt>    <dbl>\n1 ap_naive(S0 = s, K = k, r = r, q = … 224ms  236ms      3.89    23.2MB     12.8\n2 ap_v1(S0 = s, K = k, r = r, q = d, … 155ms  170ms      5.83   276.2KB     19.2\n3 ap_v2(S0 = s, K = k, r = r, q = d, … 149ms  151ms      6.63   263.2KB     21.9\n4 ap_v3(S0 = s, K = k, r = r, q = d, … 149ms  150ms      6.60   760.4KB     21.1\n```\n\n\n:::\n:::\n\n\n:::\n\n\n## Benchmarking the R implementations\n### With the sample set of 2500 options.\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div id=\"sjnthqhpgt\" style=\"padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;\">\n<style>#sjnthqhpgt table {\n  font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n#sjnthqhpgt thead, #sjnthqhpgt tbody, #sjnthqhpgt tfoot, #sjnthqhpgt tr, #sjnthqhpgt td, #sjnthqhpgt th {\n  border-style: none;\n}\n\n#sjnthqhpgt p {\n  margin: 0;\n  padding: 0;\n}\n\n#sjnthqhpgt .gt_table {\n  display: table;\n  border-collapse: collapse;\n  line-height: normal;\n  margin-left: auto;\n  margin-right: auto;\n  color: #333333;\n  font-size: 16px;\n  font-weight: normal;\n  font-style: normal;\n  background-color: #FFFFFF;\n  width: auto;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #A8A8A8;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #A8A8A8;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n}\n\n#sjnthqhpgt .gt_caption {\n  padding-top: 4px;\n  padding-bottom: 4px;\n}\n\n#sjnthqhpgt .gt_title {\n  color: #333333;\n  font-size: 125%;\n  font-weight: initial;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-color: #FFFFFF;\n  border-bottom-width: 0;\n}\n\n#sjnthqhpgt .gt_subtitle {\n  color: #333333;\n  font-size: 85%;\n  font-weight: initial;\n  padding-top: 3px;\n  padding-bottom: 5px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-color: #FFFFFF;\n  border-top-width: 0;\n}\n\n#sjnthqhpgt .gt_heading {\n  background-color: #FFFFFF;\n  text-align: center;\n  border-bottom-color: #FFFFFF;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#sjnthqhpgt .gt_bottom_border {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#sjnthqhpgt .gt_col_headings {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#sjnthqhpgt .gt_col_heading {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  overflow-x: hidden;\n}\n\n#sjnthqhpgt .gt_column_spanner_outer {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n#sjnthqhpgt .gt_column_spanner_outer:first-child {\n  padding-left: 0;\n}\n\n#sjnthqhpgt .gt_column_spanner_outer:last-child {\n  padding-right: 0;\n}\n\n#sjnthqhpgt .gt_column_spanner {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  overflow-x: hidden;\n  display: inline-block;\n  width: 100%;\n}\n\n#sjnthqhpgt .gt_spanner_row {\n  border-bottom-style: hidden;\n}\n\n#sjnthqhpgt .gt_group_heading {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  text-align: left;\n}\n\n#sjnthqhpgt .gt_empty_group_heading {\n  padding: 0.5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#sjnthqhpgt .gt_from_md > :first-child {\n  margin-top: 0;\n}\n\n#sjnthqhpgt .gt_from_md > :last-child {\n  margin-bottom: 0;\n}\n\n#sjnthqhpgt .gt_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  margin: 10px;\n  border-top-style: solid;\n  border-top-width: 1px;\n  border-top-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  overflow-x: hidden;\n}\n\n#sjnthqhpgt .gt_stub {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#sjnthqhpgt .gt_stub_row_group {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n  vertical-align: top;\n}\n\n#sjnthqhpgt .gt_row_group_first td {\n  border-top-width: 2px;\n}\n\n#sjnthqhpgt .gt_row_group_first th {\n  border-top-width: 2px;\n}\n\n#sjnthqhpgt .gt_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#sjnthqhpgt .gt_first_summary_row {\n  border-top-style: solid;\n  border-top-color: #D3D3D3;\n}\n\n#sjnthqhpgt .gt_first_summary_row.thick {\n  border-top-width: 2px;\n}\n\n#sjnthqhpgt .gt_last_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#sjnthqhpgt .gt_grand_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#sjnthqhpgt .gt_first_grand_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: double;\n  border-top-width: 6px;\n  border-top-color: #D3D3D3;\n}\n\n#sjnthqhpgt .gt_last_grand_summary_row_top {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: double;\n  border-bottom-width: 6px;\n  border-bottom-color: #D3D3D3;\n}\n\n#sjnthqhpgt .gt_striped {\n  background-color: rgba(128, 128, 128, 0.05);\n}\n\n#sjnthqhpgt .gt_table_body {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#sjnthqhpgt .gt_footnotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#sjnthqhpgt .gt_footnote {\n  margin: 0px;\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#sjnthqhpgt .gt_sourcenotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#sjnthqhpgt .gt_sourcenote {\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#sjnthqhpgt .gt_left {\n  text-align: left;\n}\n\n#sjnthqhpgt .gt_center {\n  text-align: center;\n}\n\n#sjnthqhpgt .gt_right {\n  text-align: right;\n  font-variant-numeric: tabular-nums;\n}\n\n#sjnthqhpgt .gt_font_normal {\n  font-weight: normal;\n}\n\n#sjnthqhpgt .gt_font_bold {\n  font-weight: bold;\n}\n\n#sjnthqhpgt .gt_font_italic {\n  font-style: italic;\n}\n\n#sjnthqhpgt .gt_super {\n  font-size: 65%;\n}\n\n#sjnthqhpgt .gt_footnote_marks {\n  font-size: 75%;\n  vertical-align: 0.4em;\n  position: initial;\n}\n\n#sjnthqhpgt .gt_asterisk {\n  font-size: 100%;\n  vertical-align: 0;\n}\n\n#sjnthqhpgt .gt_indent_1 {\n  text-indent: 5px;\n}\n\n#sjnthqhpgt .gt_indent_2 {\n  text-indent: 10px;\n}\n\n#sjnthqhpgt .gt_indent_3 {\n  text-indent: 15px;\n}\n\n#sjnthqhpgt .gt_indent_4 {\n  text-indent: 20px;\n}\n\n#sjnthqhpgt .gt_indent_5 {\n  text-indent: 25px;\n}\n\n#sjnthqhpgt .katex-display {\n  display: inline-flex !important;\n  margin-bottom: 0.75em !important;\n}\n\n#sjnthqhpgt div.Reactable > div.rt-table > div.rt-thead > div.rt-tr.rt-tr-group-header > div.rt-th-group:after {\n  height: 0px !important;\n}\n</style>\n<table class=\"gt_table\" data-quarto-disable-processing=\"false\" data-quarto-bootstrap=\"false\">\n  <thead>\n    <tr class=\"gt_col_headings\">\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"option_set\">option_set</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"volatility\">volatility</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"time_to_maturity\">time_to_maturity</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"asset_price\">asset_price</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"dividend_rate\">dividend_rate</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"riskless_rate\">riskless_rate</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"exercise_price\">exercise_price</th>\n    </tr>\n  </thead>\n  <tbody class=\"gt_table_body\">\n    <tr><td headers=\"option_set\" class=\"gt_row gt_right\">1</td>\n<td headers=\"volatility\" class=\"gt_row gt_right\">0.5574030</td>\n<td headers=\"time_to_maturity\" class=\"gt_row gt_right\">0.7583443</td>\n<td headers=\"asset_price\" class=\"gt_row gt_right\">101.70338</td>\n<td headers=\"dividend_rate\" class=\"gt_row gt_right\">0.035659105</td>\n<td headers=\"riskless_rate\" class=\"gt_row gt_right\">0.09927446</td>\n<td headers=\"exercise_price\" class=\"gt_row gt_right\">100</td></tr>\n    <tr><td headers=\"option_set\" class=\"gt_row gt_right\">2</td>\n<td headers=\"volatility\" class=\"gt_row gt_right\">0.5685377</td>\n<td headers=\"time_to_maturity\" class=\"gt_row gt_right\">1.0953070</td>\n<td headers=\"asset_price\" class=\"gt_row gt_right\">108.78327</td>\n<td headers=\"dividend_rate\" class=\"gt_row gt_right\">0.020800169</td>\n<td headers=\"riskless_rate\" class=\"gt_row gt_right\">0.00000000</td>\n<td headers=\"exercise_price\" class=\"gt_row gt_right\">100</td></tr>\n    <tr><td headers=\"option_set\" class=\"gt_row gt_right\">3</td>\n<td headers=\"volatility\" class=\"gt_row gt_right\">0.2430698</td>\n<td headers=\"time_to_maturity\" class=\"gt_row gt_right\">0.5483695</td>\n<td headers=\"asset_price\" class=\"gt_row gt_right\">120.04294</td>\n<td headers=\"dividend_rate\" class=\"gt_row gt_right\">0.010062093</td>\n<td headers=\"riskless_rate\" class=\"gt_row gt_right\">0.09908713</td>\n<td headers=\"exercise_price\" class=\"gt_row gt_right\">100</td></tr>\n    <tr><td headers=\"option_set\" class=\"gt_row gt_right\">4</td>\n<td headers=\"volatility\" class=\"gt_row gt_right\">0.5152238</td>\n<td headers=\"time_to_maturity\" class=\"gt_row gt_right\">0.8569535</td>\n<td headers=\"asset_price\" class=\"gt_row gt_right\">90.74575</td>\n<td headers=\"dividend_rate\" class=\"gt_row gt_right\">0.013811304</td>\n<td headers=\"riskless_rate\" class=\"gt_row gt_right\">0.08435938</td>\n<td headers=\"exercise_price\" class=\"gt_row gt_right\">100</td></tr>\n    <tr><td headers=\"option_set\" class=\"gt_row gt_right\">5</td>\n<td headers=\"volatility\" class=\"gt_row gt_right\">0.4208728</td>\n<td headers=\"time_to_maturity\" class=\"gt_row gt_right\">2.5816131</td>\n<td headers=\"asset_price\" class=\"gt_row gt_right\">107.30398</td>\n<td headers=\"dividend_rate\" class=\"gt_row gt_right\">0.002372436</td>\n<td headers=\"riskless_rate\" class=\"gt_row gt_right\">0.09318627</td>\n<td headers=\"exercise_price\" class=\"gt_row gt_right\">100</td></tr>\n    <tr><td headers=\"option_set\" class=\"gt_row gt_right\">6</td>\n<td headers=\"volatility\" class=\"gt_row gt_right\">0.3595480</td>\n<td headers=\"time_to_maturity\" class=\"gt_row gt_right\">0.2790196</td>\n<td headers=\"asset_price\" class=\"gt_row gt_right\">109.79172</td>\n<td headers=\"dividend_rate\" class=\"gt_row gt_right\">0.038926066</td>\n<td headers=\"riskless_rate\" class=\"gt_row gt_right\">0.04160950</td>\n<td headers=\"exercise_price\" class=\"gt_row gt_right\">100</td></tr>\n    <tr><td headers=\"option_set\" class=\"gt_row gt_right\">7</td>\n<td headers=\"volatility\" class=\"gt_row gt_right\">0.4682942</td>\n<td headers=\"time_to_maturity\" class=\"gt_row gt_right\">0.6898661</td>\n<td headers=\"asset_price\" class=\"gt_row gt_right\">96.67050</td>\n<td headers=\"dividend_rate\" class=\"gt_row gt_right\">0.010791985</td>\n<td headers=\"riskless_rate\" class=\"gt_row gt_right\">0.08241817</td>\n<td headers=\"exercise_price\" class=\"gt_row gt_right\">100</td></tr>\n    <tr><td headers=\"option_set\" class=\"gt_row gt_right\">8</td>\n<td headers=\"volatility\" class=\"gt_row gt_right\">0.1673333</td>\n<td headers=\"time_to_maturity\" class=\"gt_row gt_right\">0.9885690</td>\n<td headers=\"asset_price\" class=\"gt_row gt_right\">114.41327</td>\n<td headers=\"dividend_rate\" class=\"gt_row gt_right\">0.088989330</td>\n<td headers=\"riskless_rate\" class=\"gt_row gt_right\">0.07847599</td>\n<td headers=\"exercise_price\" class=\"gt_row gt_right\">100</td></tr>\n    <tr><td headers=\"option_set\" class=\"gt_row gt_right\">9</td>\n<td headers=\"volatility\" class=\"gt_row gt_right\">0.4284961</td>\n<td headers=\"time_to_maturity\" class=\"gt_row gt_right\">0.7498327</td>\n<td headers=\"asset_price\" class=\"gt_row gt_right\">92.32567</td>\n<td headers=\"dividend_rate\" class=\"gt_row gt_right\">0.029429095</td>\n<td headers=\"riskless_rate\" class=\"gt_row gt_right\">0.00000000</td>\n<td headers=\"exercise_price\" class=\"gt_row gt_right\">100</td></tr>\n    <tr><td headers=\"option_set\" class=\"gt_row gt_right\">10</td>\n<td headers=\"volatility\" class=\"gt_row gt_right\">0.4525324</td>\n<td headers=\"time_to_maturity\" class=\"gt_row gt_right\">4.8019876</td>\n<td headers=\"asset_price\" class=\"gt_row gt_right\">72.48192</td>\n<td headers=\"dividend_rate\" class=\"gt_row gt_right\">0.099098847</td>\n<td headers=\"riskless_rate\" class=\"gt_row gt_right\">0.05604909</td>\n<td headers=\"exercise_price\" class=\"gt_row gt_right\">100</td></tr>\n    <tr><td headers=\"option_set\" class=\"gt_row gt_right\">11</td>\n<td headers=\"volatility\" class=\"gt_row gt_right\">0.3288709</td>\n<td headers=\"time_to_maturity\" class=\"gt_row gt_right\">0.5439403</td>\n<td headers=\"asset_price\" class=\"gt_row gt_right\">97.16279</td>\n<td headers=\"dividend_rate\" class=\"gt_row gt_right\">0.041322451</td>\n<td headers=\"riskless_rate\" class=\"gt_row gt_right\">0.09064361</td>\n<td headers=\"exercise_price\" class=\"gt_row gt_right\">100</td></tr>\n    <tr><td headers=\"option_set\" class=\"gt_row gt_right\">12</td>\n<td headers=\"volatility\" class=\"gt_row gt_right\">0.4595561</td>\n<td headers=\"time_to_maturity\" class=\"gt_row gt_right\">2.9412671</td>\n<td headers=\"asset_price\" class=\"gt_row gt_right\">121.75869</td>\n<td headers=\"dividend_rate\" class=\"gt_row gt_right\">0.041567527</td>\n<td headers=\"riskless_rate\" class=\"gt_row gt_right\">0.09984472</td>\n<td headers=\"exercise_price\" class=\"gt_row gt_right\">100</td></tr>\n  </tbody>\n  \n</table>\n</div>\n```\n\n:::\n:::\n\n\n\n## Benchmarking the R implementations\n### With the sample set of 2500 options - Naive\n\n::: {.panel-tabset}\n\n### Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::system_time({\n  option_values_naive <- option_parameters |>\n    mutate(\n      option_value = pmap_dbl(\n        list(\n          S0 = asset_price,\n          K = exercise_price,\n          r = riskless_rate,\n          q = dividend_rate,\n          tt = time_to_maturity,\n          sigma = volatility,\n          steps = nstep\n        ),\n        ap_naive,\n        .progress = TRUE\n      )\n    )\n})\n```\n:::\n\n\n### Results\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nprocess    real \n  10.4m   10.3m \n```\n\n\n:::\n:::\n\n\n:::\n\n\n## Benchmarking the R implementations\n### With the sample set of 2500 options - R v3\n\n::: {.panel-tabset}\n\n### Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::system_time({\n  option_values_v3 <- option_parameters |>\n    mutate(\n      option_value = pmap_dbl(\n        list(\n          S0 = asset_price,\n          K = exercise_price,\n          r = riskless_rate,\n          q = dividend_rate,\n          tt = time_to_maturity,\n          sigma = volatility,\n          steps = nstep\n        ),\n        ap_v3,\n        .progress = TRUE\n      )\n    )\n})\n```\n:::\n\n\n### Results\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nprocess    real \n  6.74m   6.63m \n```\n\n\n:::\n:::\n\n\n:::\n\n\n\n## Parallel computing in R\n\nThe easiest way to reduce computational time is to use parallel computing.\n\nThis can be done in several ways, but one of the most straightforward ways to parallelize code in R is to use the [furrr](https://furrr.futureverse.org/) package.\n\nThe `furrr` package is a parallel implementation of the `purrr` package, which uses the [future](https://future.futureverse.org/) package to provide a simple and consistent API for parallel programming in R.\n\nThis allows us to parallelize code on the current machine or on a **cluster of machines**.\n\n\n## Parallel computing in R\n\nBefore doing so, it is always a good idea to create **safe versions** of the functions to capture potential errors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nap_naive_safe <- safely(ap_naive)\nap_v1_safe <- safely(ap_v1)\nap_v2_safe <- safely(ap_v2)\nap_v3_safe <- safely(ap_v3)\n```\n:::\n\n\n\n## Parallel computing in R\n\n::: {.panel-tabset}\n\n### Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplan(multisession, workers = 10)\nbench::system_time({\n  option_values_v3_par <- option_parameters |>\n    mutate(\n      option_value = future_pmap(\n        list(\n          S0 = asset_price,\n          K = exercise_price,\n          r = riskless_rate,\n          q = dividend_rate,\n          tt = time_to_maturity,\n          sigma = volatility,\n          steps = nstep\n        ),\n        ap_v3_safe,\n        .progress = TRUE\n      )\n    ) |>\n    unnest_wider(option_value, names_sep = \"_\")\n})\nplan(sequential)\n```\n:::\n\n\n\n### Results - Naive \n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nprocess    real \n  2.44s   1.18m \n```\n\n\n:::\n:::\n\n\n\n### Results - v1 \n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nprocess    real \n  1.23s  49.41s \n```\n\n\n:::\n:::\n\n\n\n### Results - v2\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nprocess    real \n  1.21s  49.29s \n```\n\n\n:::\n:::\n\n\n\n### Results - v3\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nprocess    real \n  2.83s  49.76s \n```\n\n\n:::\n:::\n\n\n:::\n\n\n## Check all implementations return the same results\n\n\nThe results are identical across all implementations:\n\n::: {.cell}\n\n```{.r .cell-code}\nidentical(\n  option_values_naive_par,\n  option_values_v1_par\n)\n\nidentical(\n  option_values_v1_par,\n  option_values_v2_par\n)\n\nidentical(\n  option_values_v2_par,\n  option_values_v3_par\n)\n```\n:::\n\n\n\n\n## Improving performance with Rcpp\n\nAnother approach to improve performance is to use a lower-level language like C++.\n\nAgain, there are several ways to do this, but one of the most straightforward ways is to use the [Rcpp package](https://www.rcpp.org/).\n\nThis package allows us to write C++ code, link and compile and call it as if it were an R function. And it makes it easy to use matrix algebra libraries like [Armadillo](https://arma.sourceforge.net/) and [Eigen](https://libeigen.gitlab.io/).\n\nFor more details see: [Rcpp](https://www.rcpp.org/)\n\n\n\n## Improving performance with Rcpp\n### Using AI to convert R to C++\n\nThis example has all the necessary components to use AI tools to convert R code to C++ code:\n\n- an algorithm already implemented in R;\n- a large dataset that can serve as a benchmark;\n- the new code can be inspected to ensure it is correct (the syntax will not be too different from R).\n\nSo we can use an AI coding agent ([claude-code](https://github.com/anthropics/claude-code), [gemini-cli](https://github.com/google-gemini/gemini-cli), [codex](https://github.com/openai/codex), [Aider](https://aider.chat/), [Cline](https://cline.bot/), etc.) to help us convert the code to C++.\n\n\n## Improving performance with Rcpp\n### Caution when using AI coding agents\n\n- Make sure that you have a comprehensive test suite\n- **Make sure that the agent does not change the test suite**\n- Use agents in YOLO mode (e.g.: `claude --dangerously-skip-permissions`) at **your own peril!** Best to use a [**sandboxed microVM**]{.alert}.\n\n\n\n## Improving performance with Rcpp\n### Using claude-code to convert R to C++\n\n![](images/claude_code_cpp_1.png){width=\"800px\"}\n\n\n## Improving performance with Rcpp\n### Using claude-code to convert R to C++\n\nThe prompt used:\n\n> *Please convert the function in @ap_v3.R to Rcpp, the focus is to maintain accuracy and improve performance.*\n\nwas [**purposefully kept simple**]{.alert} to see how well the model performs with a minimal prompt.\n\nAnd yet...\n\n\n## Improving performance with Rcpp\n### Using claude-code to convert R to C++\n\n![](images/claude_code_cpp_2.png){width=\"800px\"}\n\n\n## Improving performance with Rcpp\n### Using claude-code to convert R to C++\n\n![](images/claude_code_cpp_3.png){width=\"800px\"}\n\n\n## Improving performance with Rcpp\n### Using claude-code to convert R to C++\n\n![](images/claude_code_cpp_4.png){width=\"800px\"}\n\n\n## Improving performance with Rcpp\n### Using claude-code to convert R to C++\n\n![](images/claude_code_cpp_5.png){width=\"800px\"}\n\n\n## Improving performance with Rcpp\n### Using claude-code to convert R to C++\n\n![](images/claude_code_cpp_6.png){width=\"800px\"}\n\n\n\n## Improving performance with Rcpp\n\n::: {.panel-tabset}\n\n### R wrapper\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This function wraps the C++ implementation (ap_v3_cpp) with R-based input\n# validation. It provides the same interface as ap_v3 with improved performance.\n# The validation code is identical to ap_v3 to ensure the same error checking.\n\nap_v3_rcpp <- function(S0, K, r, q, tt, sigma, steps) {\n  # S0: Initial stock price\n  # K: Strike price\n  # r: Risk-free interest rate compounded continuously\n  # q: Dividend yield compounded continuously\n  # tt: Time to maturity in years\n  # sigma: Volatility of the underlying stock\n  # steps: Number of time steps in the binomial tree\n\n  # Input validation\n  # Check for missing arguments\n  if (\n    missing(S0) ||\n      missing(K) ||\n      missing(r) ||\n      missing(q) ||\n      missing(tt) ||\n      missing(sigma) ||\n      missing(steps)\n  ) {\n    stop(\"All arguments must be provided\")\n  }\n\n  # Check for NA or NULL values\n  if (\n    any(is.na(c(S0, K, r, q, tt, sigma, steps))) ||\n      any(is.null(c(S0, K, r, q, tt, sigma, steps)))\n  ) {\n    stop(\"Arguments cannot be NA or NULL\")\n  }\n\n  # Check that all inputs are numeric\n  if (\n    !is.numeric(S0) ||\n      !is.numeric(K) ||\n      !is.numeric(r) ||\n      !is.numeric(q) ||\n      !is.numeric(tt) ||\n      !is.numeric(sigma) ||\n      !is.numeric(steps)\n  ) {\n    stop(\"All arguments must be numeric\")\n  }\n\n  # Check that inputs are scalar (length 1)\n  if (\n    length(S0) != 1 ||\n      length(K) != 1 ||\n      length(r) != 1 ||\n      length(q) != 1 ||\n      length(tt) != 1 ||\n      length(sigma) != 1 ||\n      length(steps) != 1\n  ) {\n    stop(\"All arguments must be scalar values\")\n  }\n\n  # Validate parameter ranges\n  if (S0 <= 0) {\n    stop(\"Initial stock price (S0) must be positive\")\n  }\n\n  if (K <= 0) {\n    stop(\"Strike price (K) must be positive\")\n  }\n\n  if (tt <= 0) {\n    stop(\"Time to maturity (tt) must be positive\")\n  }\n\n  if (sigma <= 0) {\n    stop(\"Volatility (sigma) must be positive\")\n  }\n\n  if (q < 0) {\n    stop(\"Dividend yield (q) must be non-negative\")\n  }\n\n  if (steps < 1) {\n    stop(\"Number of steps must be at least 1\")\n  }\n\n  # Check that steps is an integer\n  if (steps != floor(steps)) {\n    stop(\"Number of steps must be an integer\")\n  }\n\n  # Calculate risk-neutral probability for validation\n  dt <- tt / steps\n  u <- exp(sigma * sqrt(dt))\n  d <- exp(-sigma * sqrt(dt))\n  p <- (exp((r - q) * dt) - d) / (u - d)\n\n  # Validate risk-neutral probability (arbitrage-free condition)\n  if (p < 0 || p > 1) {\n    stop(sprintf(\n      \"Risk-neutral probability p=%.4f is outside [0,1]. Model parameters lead to arbitrage.\",\n      p\n    ))\n  }\n\n  # Call C++ implementation\n  return(ap_v3_cpp(S0, K, r, q, tt, sigma, steps))\n}\n```\n:::\n\n\n### C++ code\n\n\n::: {.cell}\n\n```{.r .cell-code}\n// This is the C++ core implementation of the American put option pricing\n// algorithm using the Cox-Ross-Rubinstein binomial tree model.\n// It is designed to be called from R via the ap_v3_rcpp() wrapper function.\n\n#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble ap_v3_cpp(double S0, double K, double r, double q,\n                 double tt, double sigma, int steps) {\n  // S0: Initial stock price\n  // K: Strike price\n  // r: Risk-free interest rate compounded continuously\n  // q: Dividend yield compounded continuously\n  // tt: Time to maturity in years\n  // sigma: Volatility of the underlying stock\n  // steps: Number of time steps in the binomial tree\n\n  // Calculate binomial tree parameters\n  double dt = tt / steps;                          // Time between steps\n  double u = exp(sigma * sqrt(dt));                // Up factor\n  double d = exp(-sigma * sqrt(dt));               // Down factor\n  double p = (exp((r - q) * dt) - d) / (u - d);   // Risk-neutral probability\n  double disc = exp(-r * dt);                      // Discount factor\n\n  // Vector to store option values at each node\n  NumericVector option_values(steps + 1);\n\n  // Backward induction from maturity to root\n  // Note: C++ uses 0-based indexing, so j goes from steps to 0\n  for (int j = steps; j >= 0; j--) {\n    // Number of nodes at this time step\n    int num_nodes = (j == steps) ? (steps + 1) : (j + 1);\n\n    for (int i = 0; i < num_nodes; i++) {\n      // Calculate asset price at this node\n      // Formula: S0 * u^(j-i) * d^i\n      double asset_price = S0 * pow(u, j - i) * pow(d, i);\n\n      if (j == steps) {\n        // At maturity: option value is intrinsic value\n        option_values[i] = std::max(K - asset_price, 0.0);\n      } else {\n        // Before maturity: calculate continuation value and check early exercise\n        double continuation_value = (p * option_values[i] +\n                                    (1 - p) * option_values[i + 1]) * disc;\n        double intrinsic_value = K - asset_price;\n        option_values[i] = std::max(continuation_value, intrinsic_value);\n      }\n    }\n  }\n\n  // Return the option price at the root node\n  return option_values[0];\n}\n```\n:::\n\n\n### Source\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(Rcpp)\nRcpp::sourceCpp(here(\"R\", \"ap_v3_rcpp.cpp\"))\n```\n:::\n\n\n\n### Benchmark with one option\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench_result_one_option_rcpp <- bench::mark(\n  ap_v3(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v3_rcpp(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  min_iterations = 10L\n)\n```\n:::\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 6\n  expression                           min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr>                      <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 ap_v3(S0 = s, K = k, r = r, q … 152.23ms 156.49ms      6.42    7.87KB     24.4\n2 ap_v3_rcpp(S0 = s, K = k, r = …   7.95ms   7.99ms    125.    496.13KB      0  \n```\n\n\n:::\n:::\n\n\n:::\n\n\n\n## Improving performance with Rcpp\n### Benchmark with all options\n\n::: {.panel-tabset}\n\n### Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrcpp_v3_time_all_options <- bench::system_time({\n  option_values_rcpp <- option_parameters |>\n    mutate(\n      option_value = pmap_dbl(\n        list(\n          S0 = asset_price,\n          K = exercise_price,\n          r = riskless_rate,\n          q = dividend_rate,\n          tt = time_to_maturity,\n          sigma = volatility,\n          steps = nstep\n        ),\n        ap_v3_rcpp,\n        .progress = TRUE\n      )\n    )\n})\n```\n:::\n\n\n### Benchmark results\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrcpp_v3_time_all_options\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nprocess    real \n  20.5s   20.2s \n```\n\n\n:::\n:::\n\n\nThe results are **the same at 15 significant digits**.\n\n:::\n\n\n\n## Improving performance with Rcpp\n### Parallelization \n\nSince the Rcpp function creates an external pointer to another object in C++, we can only use it in R session where it was created. \n\nSo we need to modify the R wrapper function to create the external pointer inside the function. This is what the `ap_v3_rcpp_par` is doing.\n\n\n## Improving performance with Rcpp\n### Parallelization results - all options\n\n\n::: {.panel-tabset}\n\n### R wrapper\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplan(multisession, workers = 10)\nrcpp_v3_par_time_all_options <- bench::system_time({\n  option_values_rcpp_par <- option_parameters |>\n    mutate(\n      option_value = future_pmap(\n        list(\n          S0 = asset_price,\n          K = exercise_price,\n          r = riskless_rate,\n          q = dividend_rate,\n          tt = time_to_maturity,\n          sigma = volatility,\n          steps = nstep\n        ),\n        ap_v3_rcpp_par_safe,\n        .progress = TRUE,\n        .options = furrr_options(seed = TRUE)\n      )\n    ) |>\n    unnest_wider(option_value, names_sep = \"_\")\n})\n```\n:::\n\n\n\n### Results \n\n::: {.cell}\n\n```{.r .cell-code}\nrcpp_v3_par_time_all_options\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n process     real \n355.95ms    7.63s \n```\n\n\n:::\n:::\n\n\n**The best approach would be to create a simple package with the compiled C++ code** and then use it in parallel without the need to create the external pointer inside the function.\n\n\n### Results with package\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrcpp_v3_par_time_all_options_pkg\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n process     real \n174.79ms    2.89s \n```\n\n\n:::\n:::\n\n\n[**Much better!**]{.alert}\n\n\n:::\n\n\n\n## Improving performance with Julia\n\nAn alternative to C++ is to use [Julia](https://julialang.org/), a high-level, high-performance programming language for technical computing.\n\nWe will be using [JuliaCall](https://juliainterop.github.io/JuliaCall/index.html)\nthat allows for a seamless integration between R and Julia.\n\n\n## Improving performance with Julia\n### Using Claude-code to convert R to Julia\n\n![](images/claude_code_julia.png){width=\"800px\"}\n\n\n## Improving performance with Julia\n\n::: {.panel-tabset}\n\n### R wrapper\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# R wrapper for Julia implementation of American put option pricing\n# Uses JuliaCall package to interface with Julia\n\n# Load required package\nif (!require(\"JuliaCall\", quietly = TRUE)) {\n  stop(\n    \"JuliaCall package is required. Install it with: install.packages('JuliaCall')\"\n  )\n}\n\n# Initialize Julia (only needs to be done once per session)\n# This function will set up the Julia connection\ninit_julia_ap <- function(num_threads = \"auto\") {\n  # Set the number of Julia threads before initialization\n  # Options: \"auto\" for all cores, or a specific number like \"8\"\n  Sys.setenv(JULIA_NUM_THREADS = as.character(num_threads))\n\n  # Initialize Julia\n  julia_setup()\n\n  # Use here package to reliably find the project root\n  if (!require(\"here\", quietly = TRUE)) {\n    stop(\"here package is required. Install it with: install.packages('here')\")\n  }\n\n  # Source the Julia file from the R directory\n  julia_file <- here::here(\"R\", \"ap_v3.jl\")\n\n  if (!file.exists(julia_file)) {\n    stop(paste(\"Julia file not found:\", julia_file))\n  }\n\n  julia_source(julia_file)\n\n  # Report thread count\n  nthreads <- julia_eval(\"Threads.nthreads()\")\n  message(sprintf(\"Julia initialized with %d threads and ap_v3.jl loaded successfully\", nthreads))\n}\n\n# R function that calls the Julia implementation\nap_v3_julia <- function(S0, K, r, q, tt, sigma, steps) {\n  # Basic input validation (Julia will do more thorough validation)\n  if (\n    missing(S0) ||\n      missing(K) ||\n      missing(r) ||\n      missing(q) ||\n      missing(tt) ||\n      missing(sigma) ||\n      missing(steps)\n  ) {\n    stop(\"All arguments must be provided\")\n  }\n\n  # Call the Julia function\n  result <- julia_call(\n    \"american_put_binomial\",\n    S0,\n    K,\n    r,\n    q,\n    tt,\n    sigma,\n    as.integer(steps)\n  )\n\n  return(result)\n}\n\n# Convenience function that combines initialization and execution\n# Use this if you want a single function call\nap_v3_julia_auto <- function(\n  S0,\n  K,\n  r,\n  q,\n  tt,\n  sigma,\n  steps,\n  force_reinit = FALSE\n) {\n  # Check if Julia is already initialized\n  if (!exists(\".julia_initialized\", envir = .GlobalEnv) || force_reinit) {\n    init_julia_ap()\n    assign(\".julia_initialized\", TRUE, envir = .GlobalEnv)\n  }\n\n  ap_v3_julia(S0, K, r, q, tt, sigma, steps)\n}\n\n# Vectorized batch function that processes multiple options in Julia using multi-threading\n# This is much more efficient than calling ap_v3_julia in a loop or using R parallelization\nap_v3_julia_batch <- function(S0, K, r, q, tt, sigma, steps) {\n  # Input validation - all vectors must have the same length\n  n <- length(S0)\n\n  if (length(K) != n || length(r) != n || length(q) != n ||\n      length(tt) != n || length(sigma) != n) {\n    stop(\"All parameter vectors must have the same length\")\n  }\n\n  # Handle steps - can be a single value or a vector\n  if (length(steps) == 1) {\n    steps <- rep(steps, n)\n  } else if (length(steps) != n) {\n    stop(\"steps must be either a single value or a vector of the same length as other parameters\")\n  }\n\n  # Call the Julia batch function\n  result <- julia_call(\n    \"american_put_binomial_batch\",\n    S0,\n    K,\n    r,\n    q,\n    tt,\n    sigma,\n    as.integer(steps)\n  )\n\n  return(result)\n}\n```\n:::\n\n\n\n### Julia code\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# American Put Option Pricing using Binomial Tree\n# Julia implementation optimized for performance\n\n\"\"\"\n    american_put_binomial(S0, K, r, q, tt, sigma, steps)\n\nCalculate the price of an American put option using the Cox-Ross-Rubinstein binomial tree model.\n\n# Arguments\n- `S0::Real`: Initial stock price\n- `K::Real`: Strike price\n- `r::Real`: Risk-free interest rate (continuously compounded)\n- `q::Real`: Dividend yield (continuously compounded)\n- `tt::Real`: Time to maturity in years\n- `sigma::Real`: Volatility of the underlying stock\n- `steps::Integer`: Number of time steps in the binomial tree\n\n# Returns\n- `Float64`: Option price at the root node\n\"\"\"\nfunction american_put_binomial(S0::Real, K::Real, r::Real, q::Real,\n                                tt::Real, sigma::Real, steps::Integer)\n\n    # Input validation\n    S0 > 0 || throw(ArgumentError(\"Initial stock price (S0) must be positive\"))\n    K > 0 || throw(ArgumentError(\"Strike price (K) must be positive\"))\n    tt > 0 || throw(ArgumentError(\"Time to maturity (tt) must be positive\"))\n    sigma > 0 || throw(ArgumentError(\"Volatility (sigma) must be positive\"))\n    q >= 0 || throw(ArgumentError(\"Dividend yield (q) must be non-negative\"))\n    steps >= 1 || throw(ArgumentError(\"Number of steps must be at least 1\"))\n\n    # Calculate parameters\n    dt = tt / steps  # time between steps\n    u = exp(sigma * sqrt(dt))  # Up factor\n    d = exp(-sigma * sqrt(dt))  # Down factor\n    p = (exp((r - q) * dt) - d) / (u - d)  # Risk-neutral probability\n\n    # Validate risk-neutral probability (arbitrage-free condition)\n    if p < 0 || p > 1\n        throw(ArgumentError(\n            \"Risk-neutral probability p=$p is outside [0,1]. Model parameters lead to arbitrage.\"\n        ))\n    end\n\n    disc = exp(-r * dt)  # Discount factor\n\n    # Pre-allocate vector to store option values\n    option_values = Vector{Float64}(undef, steps + 1)\n\n    # Backward induction from maturity to root\n    for j in (steps + 1):-1:1\n        num_nodes = (j == steps + 1) ? steps + 1 : j\n\n        for i in 1:num_nodes\n            # Calculate asset price at this node\n            asset_price = S0 * u^(j - i) * d^(i - 1)\n\n            if j == steps + 1\n                # At maturity: option value is intrinsic value\n                option_values[i] = max(K - asset_price, 0.0)\n            else\n                # Before maturity: calculate continuation value and check early exercise\n                continuation_value = (p * option_values[i] +\n                                     (1 - p) * option_values[i + 1]) * disc\n                intrinsic_value = K - asset_price\n                option_values[i] = max(continuation_value, intrinsic_value)\n            end\n        end\n    end\n\n    return option_values[1]  # Option price at the root node\nend\n\n\"\"\"\n    american_put_binomial_batch(S0_vec, K_vec, r_vec, q_vec, tt_vec, sigma_vec, steps_vec)\n\nCalculate prices for multiple American put options using multi-threading.\nThis is much more efficient than calling american_put_binomial in a loop.\n\n# Arguments\nAll arguments should be vectors of the same length:\n- `S0_vec`: Vector of initial stock prices\n- `K_vec`: Vector of strike prices\n- `r_vec`: Vector of risk-free interest rates\n- `q_vec`: Vector of dividend yields\n- `tt_vec`: Vector of times to maturity\n- `sigma_vec`: Vector of volatilities\n- `steps_vec`: Vector of numbers of time steps\n\n# Returns\n- `Vector{Float64}`: Vector of option prices\n\"\"\"\nfunction american_put_binomial_batch(S0_vec::AbstractVector,\n                                     K_vec::AbstractVector,\n                                     r_vec::AbstractVector,\n                                     q_vec::AbstractVector,\n                                     tt_vec::AbstractVector,\n                                     sigma_vec::AbstractVector,\n                                     steps_vec::AbstractVector{<:Integer})\n    # Validate that all vectors have the same length\n    n = length(S0_vec)\n    if length(K_vec) != n || length(r_vec) != n || length(q_vec) != n ||\n       length(tt_vec) != n || length(sigma_vec) != n || length(steps_vec) != n\n        throw(ArgumentError(\"All input vectors must have the same length\"))\n    end\n\n    # Pre-allocate result vector\n    results = Vector{Float64}(undef, n)\n\n    # Use multi-threading to process options in parallel\n    Threads.@threads for i in 1:n\n        results[i] = american_put_binomial(\n            S0_vec[i],\n            K_vec[i],\n            r_vec[i],\n            q_vec[i],\n            tt_vec[i],\n            sigma_vec[i],\n            steps_vec[i]\n        )\n    end\n\n    return results\nend\n```\n:::\n\n\n\n### Benchmark with one option\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench_result_one_option_julia <- bench::mark(\n  ap_v3(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v3_rcpp(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v3_julia(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  min_iterations = 10L\n)\nbench_result_one_option_julia\n```\n:::\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 6\n  expression                           min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr>                      <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 ap_v3(S0 = s, K = k, r = r, q … 153.77ms 155.78ms      6.41    7.87KB     24.4\n2 ap_v3_rcpp(S0 = s, K = k, r = …   7.95ms   7.98ms    125.      7.87KB      0  \n3 ap_v3_julia(S0 = s, K = k, r =…  10.32ms  10.35ms     95.8     4.26KB      0  \n```\n\n\n:::\n:::\n\n\n:::\n\n\n## Improving performance with Julia\n### Benchmark with all options\n\n::: {.panel-tabset}\n\n### Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\njulia_v3_time_all_options <- bench::system_time({\n  option_values_julia <- option_parameters |>\n    mutate(\n      option_value = pmap_dbl(\n        list(\n          S0 = asset_price,\n          K = exercise_price,\n          r = riskless_rate,\n          q = dividend_rate,\n          tt = time_to_maturity,\n          sigma = volatility,\n          steps = nstep\n        ),\n        ap_v3_julia,\n        .progress = TRUE\n      )\n    )\n})\n```\n:::\n\n\n\n### Benchmark results\n\n\n::: {.cell}\n\n```{.r .cell-code}\njulia_v3_time_all_options\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nprocess    real \n  26.7s   26.3s \n```\n\n\n:::\n:::\n\n\nThe results are **the same at 13 significant digits**.\n\n:::\n\n\n## Improving performance with Julia\n### Parallelization \n\nThe Julia runtime needs to be started in each worker so the R wrapper function needs to include that step.\n\nOr we can do the parallelization directly in Julia.\n\n## Improving performance with Rcpp\n### Parallelization results - all options\n\n\n::: {.panel-tabset}\n\n\n### R code\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplan(multisession, workers = 8)\njulia_v3_par_time_all_options <- bench::system_time({\n  option_values_julia_par <- option_parameters |>\n    mutate(\n      option_value = future_pmap(\n        list(\n          S0 = asset_price,\n          K = exercise_price,\n          r = riskless_rate,\n          q = dividend_rate,\n          tt = time_to_maturity,\n          sigma = volatility,\n          steps = nstep\n        ),\n        ap_v3_julia_auto_safe,\n        .progress = TRUE,\n        .options = furrr_options(seed = TRUE)\n      )\n    ) |>\n    unnest_wider(option_value, names_sep = \"_\")\n})\n```\n:::\n\n\n\n### R wrapper\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# R wrapper for Julia implementation of American put option pricing\n# Uses JuliaCall package to interface with Julia\n\n# Load required package\nif (!require(\"JuliaCall\", quietly = TRUE)) {\n  stop(\n    \"JuliaCall package is required. Install it with: install.packages('JuliaCall')\"\n  )\n}\n\n# Initialize Julia (only needs to be done once per session)\n# This function will set up the Julia connection\ninit_julia_ap <- function(num_threads = \"auto\") {\n  # Set the number of Julia threads before initialization\n  # Options: \"auto\" for all cores, or a specific number like \"8\"\n  Sys.setenv(JULIA_NUM_THREADS = as.character(num_threads))\n\n  # Initialize Julia\n  julia_setup()\n\n  # Use here package to reliably find the project root\n  if (!require(\"here\", quietly = TRUE)) {\n    stop(\"here package is required. Install it with: install.packages('here')\")\n  }\n\n  # Source the Julia file from the R directory\n  julia_file <- here::here(\"R\", \"ap_v3.jl\")\n\n  if (!file.exists(julia_file)) {\n    stop(paste(\"Julia file not found:\", julia_file))\n  }\n\n  julia_source(julia_file)\n\n  # Report thread count\n  nthreads <- julia_eval(\"Threads.nthreads()\")\n  message(sprintf(\"Julia initialized with %d threads and ap_v3.jl loaded successfully\", nthreads))\n}\n\n# R function that calls the Julia implementation\nap_v3_julia <- function(S0, K, r, q, tt, sigma, steps) {\n  # Basic input validation (Julia will do more thorough validation)\n  if (\n    missing(S0) ||\n      missing(K) ||\n      missing(r) ||\n      missing(q) ||\n      missing(tt) ||\n      missing(sigma) ||\n      missing(steps)\n  ) {\n    stop(\"All arguments must be provided\")\n  }\n\n  # Call the Julia function\n  result <- julia_call(\n    \"american_put_binomial\",\n    S0,\n    K,\n    r,\n    q,\n    tt,\n    sigma,\n    as.integer(steps)\n  )\n\n  return(result)\n}\n\n# Convenience function that combines initialization and execution\n# Use this if you want a single function call\nap_v3_julia_auto <- function(\n  S0,\n  K,\n  r,\n  q,\n  tt,\n  sigma,\n  steps,\n  force_reinit = FALSE\n) {\n  # Check if Julia is already initialized\n  if (!exists(\".julia_initialized\", envir = .GlobalEnv) || force_reinit) {\n    init_julia_ap()\n    assign(\".julia_initialized\", TRUE, envir = .GlobalEnv)\n  }\n\n  ap_v3_julia(S0, K, r, q, tt, sigma, steps)\n}\n\n# Vectorized batch function that processes multiple options in Julia using multi-threading\n# This is much more efficient than calling ap_v3_julia in a loop or using R parallelization\nap_v3_julia_batch <- function(S0, K, r, q, tt, sigma, steps) {\n  # Input validation - all vectors must have the same length\n  n <- length(S0)\n\n  if (length(K) != n || length(r) != n || length(q) != n ||\n      length(tt) != n || length(sigma) != n) {\n    stop(\"All parameter vectors must have the same length\")\n  }\n\n  # Handle steps - can be a single value or a vector\n  if (length(steps) == 1) {\n    steps <- rep(steps, n)\n  } else if (length(steps) != n) {\n    stop(\"steps must be either a single value or a vector of the same length as other parameters\")\n  }\n\n  # Call the Julia batch function\n  result <- julia_call(\n    \"american_put_binomial_batch\",\n    S0,\n    K,\n    r,\n    q,\n    tt,\n    sigma,\n    as.integer(steps)\n  )\n\n  return(result)\n}\n```\n:::\n\n\n\n### Benchmark results\n\n\n::: {.cell}\n\n```{.r .cell-code}\njulia_v3_par_time_all_options\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nprocess    real \n658.4ms   11.3s \n```\n\n\n:::\n:::\n\n\nNote that the [**best approach would be to parallelize the code directly in Julia**]{.alert}, but this is just an example of how to use Julia from R in parallel.\n\n### Parallelization in Julia\n\n\n::: {.cell}\n\n```{.r .cell-code}\njulia_v3_batch_time_all_options\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nprocess    real \n 27.75s   3.51s \n```\n\n\n:::\n:::\n\n\n[**Much better!**]{.alert}\n\n\n:::\n\n\n\n## Using torch for GPU computing\n\n[Torch](http://torch.ch/)  is a scientific computing framework with wide support for machine learning algorithms and GPU computing.\n\n[PyTorch](https://pytorch.org/) is the Python implementation and [torch for R](https://torch.mlverse.org/) that mirrors PyTorch in R.\n\nThe advantage of using torch is that it provides a simple way to move data and computations to the GPU, it has the advantage of running on different hardware.\n\n\n## Using torch for GPU computing\n\nThere are many problems that can benefit from GPU computing, but not all.\n\nAnd the transition is not always straightforward. The american option pricing problem is a good example of this. See: [Chapter 45. Options Pricing on the GPU | NVIDIA Developer](https://developer.nvidia.com/gpugems/gpugems2/part-vi-simulation-and-numerical-algorithms/chapter-45-options-pricing-gpu)\n\nAlso consider numerical accuracy when using GPUs, as they may use lower precision arithmetic, the memory that is available, and the overhead of moving data between the CPU and GPU. See: [Numerical accuracy — PyTorch 2.9 documentation](https://docs.pytorch.org/docs/stable/notes/numerical_accuracy.html)\n\n\n## Using torch for GPU computing\n### Parallelization results - all options\n\n::: {.panel-tabset}\n\n### R code\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load required package\nif (!require(\"torch\", quietly = TRUE)) {\n  stop(\n    \"torch package is required. Install it with: install.packages('torch')\"\n  )\n}\n\n#' Price multiple American put options using a batched binomial tree on a GPU.\n#'\n#' This function extends the scalar CRR binomial tree implementation so that many\n#' put option contracts can be priced simultaneously. The binomial time recursion\n#' remains sequential, but each level operates on the entire batch, allowing the\n#' GPU to process wide workloads efficiently. All contracts share the same\n#' number of time steps \\code{steps}; other parameters may vary by contract.\n#'\n#' @param S0 Numeric vector of initial stock prices.\n#' @param K Numeric vector of strike prices.\n#' @param r Numeric vector of continuously compounded risk-free rates.\n#' @param q Numeric vector of dividend yields compounded continuously.\n#' @param sigma Numeric vector of volatilities.\n#' @param tt Numeric vector of times to maturity (years).\n#' @param steps Integer scalar with the number of binomial steps (shared by batch).\n#'\n#' @return Numeric vector of American put option prices, one per contract.\nap_v3_torch <- function(S0, K, r, q, tt, sigma, steps) {\n  # --- 1. Device and dtype selection ----------------------------------------------------------\n  if (torch::cuda_is_available()) {\n    device <- \"cuda\"\n    float_dtype <- torch_double()\n    message(\"CUDA device detected. Using torch_double() (float64).\")\n  } else if (torch::backends_mps_is_available()) {\n    device <- \"mps\"\n    float_dtype <- torch_float()\n    message(\"MPS device detected. Using torch_float() (float32).\")\n  } else {\n    stop(\"No compatible GPU (CUDA or MPS) available.\")\n  }\n\n  # --- 2. Input validation and broadcasting ---------------------------------------------------\n  if (length(steps) != 1) {\n    stop(\"`steps` must be a single integer shared by the batch.\")\n  }\n  steps <- as.integer(steps)\n  if (steps <= 0) {\n    stop(\"`steps` must be a positive integer.\")\n  }\n\n  lengths <- c(\n    length(S0),\n    length(K),\n    length(r),\n    length(q),\n    length(sigma),\n    length(tt)\n  )\n  if (any(lengths == 0)) {\n    stop(\"All parameters must have at least one value.\")\n  }\n  batch <- max(lengths)\n\n  broadcast_param <- function(x, name) {\n    if (length(x) == 1) {\n      rep(x, batch)\n    } else if (length(x) == batch) {\n      x\n    } else {\n      stop(sprintf(\n        \"`%s` must have length 1 or match the batch size (%d).\",\n        name,\n        batch\n      ))\n    }\n  }\n\n  S0_vec <- as.numeric(broadcast_param(S0, \"S0\"))\n  K_vec <- as.numeric(broadcast_param(K, \"K\"))\n  r_vec <- as.numeric(broadcast_param(r, \"r\"))\n  q_vec <- as.numeric(broadcast_param(q, \"q\"))\n  sigma_vec <- as.numeric(broadcast_param(sigma, \"sigma\"))\n  tt_vec <- as.numeric(broadcast_param(tt, \"tt\"))\n\n  dt_vec <- tt_vec / steps\n  if (any(dt_vec <= 0)) {\n    stop(\"All maturities must be positive.\")\n  }\n\n  u_vec <- exp(sigma_vec * sqrt(dt_vec))\n  d_vec <- 1 / u_vec\n  denom <- u_vec - d_vec\n  if (any(abs(denom) < .Machine$double.eps)) {\n    stop(\"Encountered zero denominator in probability computation.\")\n  }\n  p_vec <- (exp((r_vec - q_vec) * dt_vec) - d_vec) / denom\n  if (any(p_vec < 0 | p_vec > 1)) {\n    stop(\"Risk-neutral probability out of bounds; check inputs.\")\n  }\n  down_prob_vec <- 1 - p_vec\n  df_vec <- exp(-r_vec * dt_vec)\n\n  # --- 3. Promote scalars to batched GPU tensors ----------------------------------------------\n  S0_t <- torch_tensor(S0_vec, device = device, dtype = float_dtype)$view(c(\n    batch,\n    1,\n    1\n  ))\n  K_t <- torch_tensor(K_vec, device = device, dtype = float_dtype)$view(c(\n    batch,\n    1,\n    1\n  ))\n  u_t <- torch_tensor(u_vec, device = device, dtype = float_dtype)$view(c(\n    batch,\n    1,\n    1\n  ))\n  d_t <- torch_tensor(d_vec, device = device, dtype = float_dtype)$view(c(\n    batch,\n    1,\n    1\n  ))\n  p_line <- torch_tensor(p_vec, device = device, dtype = float_dtype)$view(c(\n    batch,\n    1,\n    1\n  ))\n  down_prob_line <- torch_tensor(\n    down_prob_vec,\n    device = device,\n    dtype = float_dtype\n  )$view(c(batch, 1, 1))\n  df_line <- torch_tensor(df_vec, device = device, dtype = float_dtype)$view(c(\n    batch,\n    1,\n    1\n  ))\n  zero_scalar <- torch_tensor(0, device = device, dtype = float_dtype)\n\n  # --- 4. Precompute stock prices and exercise values (batched) -------------------------------\n  j_seq <- torch_tensor(0:steps, device = device, dtype = float_dtype)\n  j_indices <- j_seq$view(c(1, steps + 1, 1))\n  n_seq <- torch_tensor(0:steps, device = device, dtype = float_dtype)\n  n_indices <- n_seq$view(c(1, 1, steps + 1))\n\n  S_all <- S0_t * (u_t$pow(j_indices)) * (d_t$pow(n_indices - j_indices))\n\n  # Compute put payoffs: max(K - S, 0)\n  ex_all <- torch_maximum(K_t - S_all, zero_scalar)\n\n  # --- 5. Backward induction across the batch -------------------------------------------------\n  V <- ex_all$narrow(3, steps + 1, 1)\n\n  for (n in (steps - 1):0) {\n    n_nodes <- n + 1\n\n    V_up <- V$narrow(2, 2, n_nodes)\n    V_down <- V$narrow(2, 1, n_nodes)\n    V_hold <- df_line * (p_line * V_up + down_prob_line * V_down)\n\n    V_ex <- ex_all$narrow(2, 1, n_nodes)$narrow(3, n + 1, 1)\n    V <- torch_maximum(V_hold, V_ex)\n  }\n\n  # --- 6. Return one price per contract -------------------------------------------------------\n  as.numeric(V$squeeze())\n}\n```\n:::\n\n\n\n### Benchmark results\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Batch size = 500 (5 batches)\ntorch_v3_time_batch_500 <- bench::system_time({\n  option_values_torch_500 <- process_torch_batches(\n    option_parameters,\n    batch_size = 500,\n    nstep = nstep\n  )\n})\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntorch_v3_time_batch_500\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nprocess    real \n  22.6s   22.2s \n```\n\n\n:::\n:::\n\n\nThey are only equal up to [**4 significant digits**]{.alert} due to differences in floating point arithmetic on the GPU. On a mac the GPU uses 32-bit floats by default which limits precision.\n\n:::\n\n\n## Summary\n\n:::{.large}\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div id=\"hquqbwhuml\" style=\"padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;\">\n<style>#hquqbwhuml table {\n  font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n#hquqbwhuml thead, #hquqbwhuml tbody, #hquqbwhuml tfoot, #hquqbwhuml tr, #hquqbwhuml td, #hquqbwhuml th {\n  border-style: none;\n}\n\n#hquqbwhuml p {\n  margin: 0;\n  padding: 0;\n}\n\n#hquqbwhuml .gt_table {\n  display: table;\n  border-collapse: collapse;\n  line-height: normal;\n  margin-left: auto;\n  margin-right: auto;\n  color: #333333;\n  font-size: 16px;\n  font-weight: normal;\n  font-style: normal;\n  background-color: #FFFFFF;\n  width: auto;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #A8A8A8;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #A8A8A8;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n}\n\n#hquqbwhuml .gt_caption {\n  padding-top: 4px;\n  padding-bottom: 4px;\n}\n\n#hquqbwhuml .gt_title {\n  color: #333333;\n  font-size: 125%;\n  font-weight: initial;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-color: #FFFFFF;\n  border-bottom-width: 0;\n}\n\n#hquqbwhuml .gt_subtitle {\n  color: #333333;\n  font-size: 85%;\n  font-weight: initial;\n  padding-top: 3px;\n  padding-bottom: 5px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-color: #FFFFFF;\n  border-top-width: 0;\n}\n\n#hquqbwhuml .gt_heading {\n  background-color: #FFFFFF;\n  text-align: center;\n  border-bottom-color: #FFFFFF;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#hquqbwhuml .gt_bottom_border {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#hquqbwhuml .gt_col_headings {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#hquqbwhuml .gt_col_heading {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  overflow-x: hidden;\n}\n\n#hquqbwhuml .gt_column_spanner_outer {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n#hquqbwhuml .gt_column_spanner_outer:first-child {\n  padding-left: 0;\n}\n\n#hquqbwhuml .gt_column_spanner_outer:last-child {\n  padding-right: 0;\n}\n\n#hquqbwhuml .gt_column_spanner {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  overflow-x: hidden;\n  display: inline-block;\n  width: 100%;\n}\n\n#hquqbwhuml .gt_spanner_row {\n  border-bottom-style: hidden;\n}\n\n#hquqbwhuml .gt_group_heading {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  text-align: left;\n}\n\n#hquqbwhuml .gt_empty_group_heading {\n  padding: 0.5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#hquqbwhuml .gt_from_md > :first-child {\n  margin-top: 0;\n}\n\n#hquqbwhuml .gt_from_md > :last-child {\n  margin-bottom: 0;\n}\n\n#hquqbwhuml .gt_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  margin: 10px;\n  border-top-style: solid;\n  border-top-width: 1px;\n  border-top-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  overflow-x: hidden;\n}\n\n#hquqbwhuml .gt_stub {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#hquqbwhuml .gt_stub_row_group {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n  vertical-align: top;\n}\n\n#hquqbwhuml .gt_row_group_first td {\n  border-top-width: 2px;\n}\n\n#hquqbwhuml .gt_row_group_first th {\n  border-top-width: 2px;\n}\n\n#hquqbwhuml .gt_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#hquqbwhuml .gt_first_summary_row {\n  border-top-style: solid;\n  border-top-color: #D3D3D3;\n}\n\n#hquqbwhuml .gt_first_summary_row.thick {\n  border-top-width: 2px;\n}\n\n#hquqbwhuml .gt_last_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#hquqbwhuml .gt_grand_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#hquqbwhuml .gt_first_grand_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: double;\n  border-top-width: 6px;\n  border-top-color: #D3D3D3;\n}\n\n#hquqbwhuml .gt_last_grand_summary_row_top {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: double;\n  border-bottom-width: 6px;\n  border-bottom-color: #D3D3D3;\n}\n\n#hquqbwhuml .gt_striped {\n  background-color: rgba(128, 128, 128, 0.05);\n}\n\n#hquqbwhuml .gt_table_body {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#hquqbwhuml .gt_footnotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#hquqbwhuml .gt_footnote {\n  margin: 0px;\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#hquqbwhuml .gt_sourcenotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#hquqbwhuml .gt_sourcenote {\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#hquqbwhuml .gt_left {\n  text-align: left;\n}\n\n#hquqbwhuml .gt_center {\n  text-align: center;\n}\n\n#hquqbwhuml .gt_right {\n  text-align: right;\n  font-variant-numeric: tabular-nums;\n}\n\n#hquqbwhuml .gt_font_normal {\n  font-weight: normal;\n}\n\n#hquqbwhuml .gt_font_bold {\n  font-weight: bold;\n}\n\n#hquqbwhuml .gt_font_italic {\n  font-style: italic;\n}\n\n#hquqbwhuml .gt_super {\n  font-size: 65%;\n}\n\n#hquqbwhuml .gt_footnote_marks {\n  font-size: 75%;\n  vertical-align: 0.4em;\n  position: initial;\n}\n\n#hquqbwhuml .gt_asterisk {\n  font-size: 100%;\n  vertical-align: 0;\n}\n\n#hquqbwhuml .gt_indent_1 {\n  text-indent: 5px;\n}\n\n#hquqbwhuml .gt_indent_2 {\n  text-indent: 10px;\n}\n\n#hquqbwhuml .gt_indent_3 {\n  text-indent: 15px;\n}\n\n#hquqbwhuml .gt_indent_4 {\n  text-indent: 20px;\n}\n\n#hquqbwhuml .gt_indent_5 {\n  text-indent: 25px;\n}\n\n#hquqbwhuml .katex-display {\n  display: inline-flex !important;\n  margin-bottom: 0.75em !important;\n}\n\n#hquqbwhuml div.Reactable > div.rt-table > div.rt-thead > div.rt-tr.rt-tr-group-header > div.rt-th-group:after {\n  height: 0px !important;\n}\n</style>\n<table class=\"gt_table\" data-quarto-disable-processing=\"false\" data-quarto-bootstrap=\"false\">\n  <thead>\n    <tr class=\"gt_col_headings\">\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_left\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"approach\">approach</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"time\">time</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"speedup\">speedup</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_left\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"time-in-minutes\">time in minutes</th>\n    </tr>\n  </thead>\n  <tbody class=\"gt_table_body\">\n    <tr><td headers=\"approach\" class=\"gt_row gt_left\">Naive R</td>\n<td headers=\"time\" class=\"gt_row gt_right\">615.178376</td>\n<td headers=\"speedup\" class=\"gt_row gt_right\">1.000000</td>\n<td headers=\"time in minutes\" class=\"gt_row gt_left\">10.25m</td></tr>\n    <tr><td headers=\"approach\" class=\"gt_row gt_left\">V3 R</td>\n<td headers=\"time\" class=\"gt_row gt_right\">397.953494</td>\n<td headers=\"speedup\" class=\"gt_row gt_right\">1.545855</td>\n<td headers=\"time in minutes\" class=\"gt_row gt_left\"> 6.63m</td></tr>\n    <tr><td headers=\"approach\" class=\"gt_row gt_left\">V3 R parallel</td>\n<td headers=\"time\" class=\"gt_row gt_right\">49.760343</td>\n<td headers=\"speedup\" class=\"gt_row gt_right\">12.362824</td>\n<td headers=\"time in minutes\" class=\"gt_row gt_left\">49.76s</td></tr>\n    <tr><td headers=\"approach\" class=\"gt_row gt_left\">V3 Rcpp parallel</td>\n<td headers=\"time\" class=\"gt_row gt_right\">7.634587</td>\n<td headers=\"speedup\" class=\"gt_row gt_right\">80.577820</td>\n<td headers=\"time in minutes\" class=\"gt_row gt_left\"> 7.63s</td></tr>\n    <tr><td headers=\"approach\" class=\"gt_row gt_left\">V3 Rcpp parallel (package)</td>\n<td headers=\"time\" class=\"gt_row gt_right\">2.893948</td>\n<td headers=\"speedup\" class=\"gt_row gt_right\">212.574072</td>\n<td headers=\"time in minutes\" class=\"gt_row gt_left\"> 2.89s</td></tr>\n    <tr><td headers=\"approach\" class=\"gt_row gt_left\">V3 Julia (parallelization in R)</td>\n<td headers=\"time\" class=\"gt_row gt_right\">11.334777</td>\n<td headers=\"speedup\" class=\"gt_row gt_right\">54.273531</td>\n<td headers=\"time in minutes\" class=\"gt_row gt_left\">11.34s</td></tr>\n    <tr><td headers=\"approach\" class=\"gt_row gt_left\">V3 Julia (parallelization in Julia)</td>\n<td headers=\"time\" class=\"gt_row gt_right\">3.512169</td>\n<td headers=\"speedup\" class=\"gt_row gt_right\">175.156238</td>\n<td headers=\"time in minutes\" class=\"gt_row gt_left\"> 3.51s</td></tr>\n  </tbody>\n  \n</table>\n</div>\n```\n\n:::\n:::\n\n\n:::\n\n\n# HDFE regression {background-color=\"#A1BC98\"}\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}