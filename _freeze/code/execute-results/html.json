{
  "hash": "37889d5601bd3d85e2a329736571dfb8",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R, C++ and Julia code\"\nformat: \n    html:\n      toc: true\n      toc-location: right\n      toc-depth: 3\n      number-sections: true\n---\n\nYou can find below the functions implemented in R, C++ and Julia.\n\n# R Code\n\n## Different implementations of american put option using binomial trees\n\n### `ap_naive.R`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This function implements a bionomial tree algorithm for\n# valuing American put options using Cox-Ross-Rubinstein parameters.\n\nap_naive <- function(S0, K, r, q, tt, sigma, steps) {\n  # S0: Initial stock price\n  # K: Strike price\n  # r: Risk-free interest rate compounded continuously\n  # q: Dividend yield compounded continuously\n  # tt: Time to maturity in years\n  # sigma: Volatility of the underlying stock\n  # steps: Number of time steps in the binomial tree\n\n  dt <- tt / steps # time between steps\n  u <- exp(sigma * sqrt(dt)) # Up factor\n  d <- exp(-sigma * sqrt(dt)) # Down factor\n  p <- (exp((r - q) * dt) - d) / (u - d) # Risk-neutral probability\n\n  # Initialize matrices for asset prices and option values\n  # Rows represent nodes (i), columns represent time steps (j)\n  asset_prices <- matrix(NA, nrow = steps + 1, ncol = steps + 1)\n  option_values <- matrix(NA, nrow = steps + 1, ncol = steps + 1)\n\n  # Fill in asset prices for all nodes in the tree (lower triangular)\n  for (j in 1:(steps + 1)) {\n    for (i in (steps + 2 - j):(steps + 1)) {\n      asset_prices[i, j] <- S0 * u^(steps + 1 - i) * d^(i + j - steps - 2)\n    }\n  }\n\n  # Initialize option values at maturity (last column)\n  for (i in 1:(steps + 1)) {\n    option_values[i, steps + 1] <- max(K - asset_prices[i, steps + 1], 0)\n  }\n\n  # Backward induction to calculate option price at earlier nodes\n  # i - node, j - time step\n  for (j in steps:1) {\n    for (i in (steps + 2 - j):(steps + 1)) {\n      # Calculate continuation value\n      option_values[i, j] <-\n        (p * option_values[i - 1, j + 1] + (1 - p) * option_values[i, j + 1]) *\n        exp(-r * dt)\n\n      # Check for early exercise\n      intrinsic_value <- K - asset_prices[i, j]\n      option_values[i, j] <- max(option_values[i, j], intrinsic_value)\n    }\n  }\n\n  return(option_values[steps + 1, 1]) # Option price at the root node\n}\n```\n:::\n\n\n\n### `ap_v1.R`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This function implements an optimized binomial tree algorithm for\n# valuing American put options using Cox-Ross-Rubinstein parameters.\n# Optimization:\n# Uses vectors instead of matrices and calculates asset prices on the fly.\n\nap_v1 <- function(S0, K, r, q, tt, sigma, steps) {\n  # S0: Initial stock price\n  # K: Strike price\n  # r: Risk-free interest rate compounded continuously\n  # q: Dividend yield compounded continuously\n  # tt: Time to maturity in years\n  # sigma: Volatility of the underlying stock\n  # steps: Number of time steps in the binomial tree\n\n  dt <- tt / steps # time between steps\n  u <- exp(sigma * sqrt(dt)) # Up factor\n  d <- exp(-sigma * sqrt(dt)) # Down factor\n  p <- (exp((r - q) * dt) - d) / (u - d) # Risk-neutral probability\n  disc <- exp(-r * dt) # Discount factor\n\n  # Initialize option values at maturity\n  # Vector size is steps + 1 (for nodes 0 to steps)\n  option_values <- numeric(steps + 1)\n\n  # Calculate option values at maturity\n  for (i in 1:(steps + 1)) {\n    # At maturity, node i has (steps + 1 - i) up moves and (i - 1) down moves\n    asset_price <- S0 * u^(steps + 1 - i) * d^(i - 1)\n    option_values[i] <- max(K - asset_price, 0)\n  }\n\n  # Backward induction to calculate option price at earlier nodes\n  for (j in steps:1) {\n    # At time step j, we have j nodes\n    for (i in 1:j) {\n      # Calculate continuation value\n      option_values[i] <- (p *\n        option_values[i] +\n        (1 - p) * option_values[i + 1]) *\n        disc\n\n      # Calculate asset price for early exercise check\n      # At time step j-1, node i has (j - i) up moves and (i - 1) down moves\n      asset_price <- S0 * u^(j - i) * d^(i - 1)\n\n      # Check for early exercise\n      intrinsic_value <- K - asset_price\n      option_values[i] <- max(option_values[i], intrinsic_value)\n    }\n  }\n\n  return(option_values[1]) # Option price at the root node\n}\n```\n:::\n\n\n\n### `ap_v2.R`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This function implements an optimized binomial tree algorithm for\n# valuing American put options using Cox-Ross-Rubinstein parameters.\n# Optimization:\n# Uses vectors instead of matrices and calculates asset prices on the fly\n# and removes one loop in relation to ap_v1.\n\nap_v2 <- function(S0, K, r, q, tt, sigma, steps) {\n  # S0: Initial stock price\n  # K: Strike price\n  # r: Risk-free interest rate compounded continuously\n  # q: Dividend yield compounded continuously\n  # tt: Time to maturity in years\n  # sigma: Volatility of the underlying stock\n  # steps: Number of time steps in the binomial tree\n\n  dt <- tt / steps # time between steps\n  u <- exp(sigma * sqrt(dt)) # Up factor\n  d <- exp(-sigma * sqrt(dt)) # Down factor\n  p <- (exp((r - q) * dt) - d) / (u - d) # Risk-neutral probability\n  disc <- exp(-r * dt) # Discount factor\n\n  # Vector to store option values\n  option_values <- numeric(steps + 1)\n\n  # Backward induction from maturity to root\n  for (j in (steps + 1):1) {\n    num_nodes <- if (j == steps + 1) steps + 1 else j\n\n    for (i in 1:num_nodes) {\n      # Calculate asset price at this node\n      asset_price <- S0 * u^(j - i) * d^(i - 1)\n\n      if (j == steps + 1) {\n        # At maturity: option value is intrinsic value\n        option_values[i] <- max(K - asset_price, 0)\n      } else {\n        # Before maturity: calculate continuation value and check early exercise\n        continuation_value <- (p *\n          option_values[i] +\n          (1 - p) * option_values[i + 1]) *\n          disc\n        intrinsic_value <- K - asset_price\n        option_values[i] <- max(continuation_value, intrinsic_value)\n      }\n    }\n  }\n\n  return(option_values[1]) # Option price at the root node\n}\n```\n:::\n\n\n\n### `ap_v3.R`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This function implements an optimized binomial tree algorithm for\n# valuing American put options using Cox-Ross-Rubinstein parameters.\n# In relation to ap_v2 includes defensive programming with input validation.\n\nap_v3 <- function(S0, K, r, q, tt, sigma, steps) {\n  # S0: Initial stock price\n  # K: Strike price\n  # r: Risk-free interest rate compounded continuously\n  # q: Dividend yield compounded continuously\n  # tt: Time to maturity in years\n  # sigma: Volatility of the underlying stock\n  # steps: Number of time steps in the binomial tree\n\n  # Input validation\n  # Check for missing arguments\n  if (\n    missing(S0) ||\n      missing(K) ||\n      missing(r) ||\n      missing(q) ||\n      missing(tt) ||\n      missing(sigma) ||\n      missing(steps)\n  ) {\n    stop(\"All arguments must be provided\")\n  }\n\n  # Check for NA or NULL values\n  if (\n    any(is.na(c(S0, K, r, q, tt, sigma, steps))) ||\n      any(is.null(c(S0, K, r, q, tt, sigma, steps)))\n  ) {\n    stop(\"Arguments cannot be NA or NULL\")\n  }\n\n  # Check that all inputs are numeric\n  if (\n    !is.numeric(S0) ||\n      !is.numeric(K) ||\n      !is.numeric(r) ||\n      !is.numeric(q) ||\n      !is.numeric(tt) ||\n      !is.numeric(sigma) ||\n      !is.numeric(steps)\n  ) {\n    stop(\"All arguments must be numeric\")\n  }\n\n  # Check that inputs are scalar (length 1)\n  if (\n    length(S0) != 1 ||\n      length(K) != 1 ||\n      length(r) != 1 ||\n      length(q) != 1 ||\n      length(tt) != 1 ||\n      length(sigma) != 1 ||\n      length(steps) != 1\n  ) {\n    stop(\"All arguments must be scalar values\")\n  }\n\n  # Validate parameter ranges\n  if (S0 <= 0) {\n    stop(\"Initial stock price (S0) must be positive\")\n  }\n\n  if (K <= 0) {\n    stop(\"Strike price (K) must be positive\")\n  }\n\n  if (tt <= 0) {\n    stop(\"Time to maturity (tt) must be positive\")\n  }\n\n  if (sigma <= 0) {\n    stop(\"Volatility (sigma) must be positive\")\n  }\n\n  if (q < 0) {\n    stop(\"Dividend yield (q) must be non-negative\")\n  }\n\n  if (steps < 1) {\n    stop(\"Number of steps must be at least 1\")\n  }\n\n  # Check that steps is an integer\n  if (steps != floor(steps)) {\n    stop(\"Number of steps must be an integer\")\n  }\n\n  # Calculate parameters\n  dt <- tt / steps # time between steps\n  u <- exp(sigma * sqrt(dt)) # Up factor\n  d <- exp(-sigma * sqrt(dt)) # Down factor\n  p <- (exp((r - q) * dt) - d) / (u - d) # Risk-neutral probability\n\n  # Validate risk-neutral probability (arbitrage-free condition)\n  if (p < 0 || p > 1) {\n    stop(sprintf(\n      \"Risk-neutral probability p=%.4f is outside [0,1]. Model parameters lead to arbitrage.\",\n      p\n    ))\n  }\n\n  disc <- exp(-r * dt) # Discount factor\n\n  # Vector to store option values\n  option_values <- numeric(steps + 1)\n\n  # Backward induction from maturity to root\n  for (j in (steps + 1):1) {\n    num_nodes <- if (j == steps + 1) steps + 1 else j\n\n    for (i in 1:num_nodes) {\n      # Calculate asset price at this node\n      asset_price <- S0 * u^(j - i) * d^(i - 1)\n\n      if (j == steps + 1) {\n        # At maturity: option value is intrinsic value\n        option_values[i] <- max(K - asset_price, 0)\n      } else {\n        # Before maturity: calculate continuation value and check early exercise\n        continuation_value <- (p *\n          option_values[i] +\n          (1 - p) * option_values[i + 1]) *\n          disc\n        intrinsic_value <- K - asset_price\n        option_values[i] <- max(continuation_value, intrinsic_value)\n      }\n    }\n  }\n\n  return(option_values[1]) # Option price at the root node\n}\n```\n:::\n\n\n\n### `ap_v3_torch.R`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load required package\nif (!require(\"torch\", quietly = TRUE)) {\n  stop(\n    \"torch package is required. Install it with: install.packages('torch')\"\n  )\n}\n\n#' Price multiple American put options using a batched binomial tree on a GPU.\n#'\n#' This function extends the scalar CRR binomial tree implementation so that many\n#' put option contracts can be priced simultaneously. The binomial time recursion\n#' remains sequential, but each level operates on the entire batch, allowing the\n#' GPU to process wide workloads efficiently. All contracts share the same\n#' number of time steps \\code{steps}; other parameters may vary by contract.\n#'\n#' @param S0 Numeric vector of initial stock prices.\n#' @param K Numeric vector of strike prices.\n#' @param r Numeric vector of continuously compounded risk-free rates.\n#' @param q Numeric vector of dividend yields compounded continuously.\n#' @param sigma Numeric vector of volatilities.\n#' @param tt Numeric vector of times to maturity (years).\n#' @param steps Integer scalar with the number of binomial steps (shared by batch).\n#'\n#' @return Numeric vector of American put option prices, one per contract.\nap_v3_torch <- function(S0, K, r, q, tt, sigma, steps) {\n  # --- 1. Device and dtype selection ----------------------------------------------------------\n  if (torch::cuda_is_available()) {\n    device <- \"cuda\"\n    float_dtype <- torch_double()\n    message(\"CUDA device detected. Using torch_double() (float64).\")\n  } else if (torch::backends_mps_is_available()) {\n    device <- \"mps\"\n    float_dtype <- torch_float()\n    message(\"MPS device detected. Using torch_float() (float32).\")\n  } else {\n    stop(\"No compatible GPU (CUDA or MPS) available.\")\n  }\n\n  # --- 2. Input validation and broadcasting ---------------------------------------------------\n  if (length(steps) != 1) {\n    stop(\"`steps` must be a single integer shared by the batch.\")\n  }\n  steps <- as.integer(steps)\n  if (steps <= 0) {\n    stop(\"`steps` must be a positive integer.\")\n  }\n\n  lengths <- c(\n    length(S0),\n    length(K),\n    length(r),\n    length(q),\n    length(sigma),\n    length(tt)\n  )\n  if (any(lengths == 0)) {\n    stop(\"All parameters must have at least one value.\")\n  }\n  batch <- max(lengths)\n\n  broadcast_param <- function(x, name) {\n    if (length(x) == 1) {\n      rep(x, batch)\n    } else if (length(x) == batch) {\n      x\n    } else {\n      stop(sprintf(\n        \"`%s` must have length 1 or match the batch size (%d).\",\n        name,\n        batch\n      ))\n    }\n  }\n\n  S0_vec <- as.numeric(broadcast_param(S0, \"S0\"))\n  K_vec <- as.numeric(broadcast_param(K, \"K\"))\n  r_vec <- as.numeric(broadcast_param(r, \"r\"))\n  q_vec <- as.numeric(broadcast_param(q, \"q\"))\n  sigma_vec <- as.numeric(broadcast_param(sigma, \"sigma\"))\n  tt_vec <- as.numeric(broadcast_param(tt, \"tt\"))\n\n  dt_vec <- tt_vec / steps\n  if (any(dt_vec <= 0)) {\n    stop(\"All maturities must be positive.\")\n  }\n\n  u_vec <- exp(sigma_vec * sqrt(dt_vec))\n  d_vec <- 1 / u_vec\n  denom <- u_vec - d_vec\n  if (any(abs(denom) < .Machine$double.eps)) {\n    stop(\"Encountered zero denominator in probability computation.\")\n  }\n  p_vec <- (exp((r_vec - q_vec) * dt_vec) - d_vec) / denom\n  if (any(p_vec < 0 | p_vec > 1)) {\n    stop(\"Risk-neutral probability out of bounds; check inputs.\")\n  }\n  down_prob_vec <- 1 - p_vec\n  df_vec <- exp(-r_vec * dt_vec)\n\n  # --- 3. Promote scalars to batched GPU tensors ----------------------------------------------\n  S0_t <- torch_tensor(S0_vec, device = device, dtype = float_dtype)$view(c(\n    batch,\n    1,\n    1\n  ))\n  K_t <- torch_tensor(K_vec, device = device, dtype = float_dtype)$view(c(\n    batch,\n    1,\n    1\n  ))\n  u_t <- torch_tensor(u_vec, device = device, dtype = float_dtype)$view(c(\n    batch,\n    1,\n    1\n  ))\n  d_t <- torch_tensor(d_vec, device = device, dtype = float_dtype)$view(c(\n    batch,\n    1,\n    1\n  ))\n  p_line <- torch_tensor(p_vec, device = device, dtype = float_dtype)$view(c(\n    batch,\n    1,\n    1\n  ))\n  down_prob_line <- torch_tensor(\n    down_prob_vec,\n    device = device,\n    dtype = float_dtype\n  )$view(c(batch, 1, 1))\n  df_line <- torch_tensor(df_vec, device = device, dtype = float_dtype)$view(c(\n    batch,\n    1,\n    1\n  ))\n  zero_scalar <- torch_tensor(0, device = device, dtype = float_dtype)\n\n  # --- 4. Precompute stock prices and exercise values (batched) -------------------------------\n  j_seq <- torch_tensor(0:steps, device = device, dtype = float_dtype)\n  j_indices <- j_seq$view(c(1, steps + 1, 1))\n  n_seq <- torch_tensor(0:steps, device = device, dtype = float_dtype)\n  n_indices <- n_seq$view(c(1, 1, steps + 1))\n\n  S_all <- S0_t * (u_t$pow(j_indices)) * (d_t$pow(n_indices - j_indices))\n\n  # Compute put payoffs: max(K - S, 0)\n  ex_all <- torch_maximum(K_t - S_all, zero_scalar)\n\n  # --- 5. Backward induction across the batch -------------------------------------------------\n  V <- ex_all$narrow(3, steps + 1, 1)\n\n  for (n in (steps - 1):0) {\n    n_nodes <- n + 1\n\n    V_up <- V$narrow(2, 2, n_nodes)\n    V_down <- V$narrow(2, 1, n_nodes)\n    V_hold <- df_line * (p_line * V_up + down_prob_line * V_down)\n\n    V_ex <- ex_all$narrow(2, 1, n_nodes)$narrow(3, n + 1, 1)\n    V <- torch_maximum(V_hold, V_ex)\n  }\n\n  # --- 6. Return one price per contract -------------------------------------------------------\n  as.numeric(V$squeeze())\n}\n```\n:::\n\n\n\n## R wrappers to call C++ and Julia implementations\n\n### `ap_v3_rcpp.R`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This function wraps the C++ implementation (ap_v3_cpp) with R-based input\n# validation. It provides the same interface as ap_v3 with improved performance.\n# The validation code is identical to ap_v3 to ensure the same error checking.\n\nap_v3_rcpp <- function(S0, K, r, q, tt, sigma, steps) {\n  # S0: Initial stock price\n  # K: Strike price\n  # r: Risk-free interest rate compounded continuously\n  # q: Dividend yield compounded continuously\n  # tt: Time to maturity in years\n  # sigma: Volatility of the underlying stock\n  # steps: Number of time steps in the binomial tree\n\n  # Input validation\n  # Check for missing arguments\n  if (\n    missing(S0) ||\n      missing(K) ||\n      missing(r) ||\n      missing(q) ||\n      missing(tt) ||\n      missing(sigma) ||\n      missing(steps)\n  ) {\n    stop(\"All arguments must be provided\")\n  }\n\n  # Check for NA or NULL values\n  if (\n    any(is.na(c(S0, K, r, q, tt, sigma, steps))) ||\n      any(is.null(c(S0, K, r, q, tt, sigma, steps)))\n  ) {\n    stop(\"Arguments cannot be NA or NULL\")\n  }\n\n  # Check that all inputs are numeric\n  if (\n    !is.numeric(S0) ||\n      !is.numeric(K) ||\n      !is.numeric(r) ||\n      !is.numeric(q) ||\n      !is.numeric(tt) ||\n      !is.numeric(sigma) ||\n      !is.numeric(steps)\n  ) {\n    stop(\"All arguments must be numeric\")\n  }\n\n  # Check that inputs are scalar (length 1)\n  if (\n    length(S0) != 1 ||\n      length(K) != 1 ||\n      length(r) != 1 ||\n      length(q) != 1 ||\n      length(tt) != 1 ||\n      length(sigma) != 1 ||\n      length(steps) != 1\n  ) {\n    stop(\"All arguments must be scalar values\")\n  }\n\n  # Validate parameter ranges\n  if (S0 <= 0) {\n    stop(\"Initial stock price (S0) must be positive\")\n  }\n\n  if (K <= 0) {\n    stop(\"Strike price (K) must be positive\")\n  }\n\n  if (tt <= 0) {\n    stop(\"Time to maturity (tt) must be positive\")\n  }\n\n  if (sigma <= 0) {\n    stop(\"Volatility (sigma) must be positive\")\n  }\n\n  if (q < 0) {\n    stop(\"Dividend yield (q) must be non-negative\")\n  }\n\n  if (steps < 1) {\n    stop(\"Number of steps must be at least 1\")\n  }\n\n  # Check that steps is an integer\n  if (steps != floor(steps)) {\n    stop(\"Number of steps must be an integer\")\n  }\n\n  # Calculate risk-neutral probability for validation\n  dt <- tt / steps\n  u <- exp(sigma * sqrt(dt))\n  d <- exp(-sigma * sqrt(dt))\n  p <- (exp((r - q) * dt) - d) / (u - d)\n\n  # Validate risk-neutral probability (arbitrage-free condition)\n  if (p < 0 || p > 1) {\n    stop(sprintf(\n      \"Risk-neutral probability p=%.4f is outside [0,1]. Model parameters lead to arbitrage.\",\n      p\n    ))\n  }\n\n  # Call C++ implementation\n  return(ap_v3_cpp(S0, K, r, q, tt, sigma, steps))\n}\n```\n:::\n\n\n\n### `ap_v3_rcpp_par.R`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This function wraps the C++ implementation (ap_v3_cpp) with R-based input\n# validation. It provides the same interface as ap_v3 with improved performance.\n# The validation code is identical to ap_v3 to ensure the same error checking.\n\nap_v3_rcpp_par <- function(S0, K, r, q, tt, sigma, steps) {\n  # S0: Initial stock price\n  # K: Strike price\n  # r: Risk-free interest rate compounded continuously\n  # q: Dividend yield compounded continuously\n  # tt: Time to maturity in years\n  # sigma: Volatility of the underlying stock\n  # steps: Number of time steps in the binomial tree\n\n  # Input validation\n  # Check for missing arguments\n  if (\n    missing(S0) ||\n      missing(K) ||\n      missing(r) ||\n      missing(q) ||\n      missing(tt) ||\n      missing(sigma) ||\n      missing(steps)\n  ) {\n    stop(\"All arguments must be provided\")\n  }\n\n  # Check for NA or NULL values\n  if (\n    any(is.na(c(S0, K, r, q, tt, sigma, steps))) ||\n      any(is.null(c(S0, K, r, q, tt, sigma, steps)))\n  ) {\n    stop(\"Arguments cannot be NA or NULL\")\n  }\n\n  # Check that all inputs are numeric\n  if (\n    !is.numeric(S0) ||\n      !is.numeric(K) ||\n      !is.numeric(r) ||\n      !is.numeric(q) ||\n      !is.numeric(tt) ||\n      !is.numeric(sigma) ||\n      !is.numeric(steps)\n  ) {\n    stop(\"All arguments must be numeric\")\n  }\n\n  # Check that inputs are scalar (length 1)\n  if (\n    length(S0) != 1 ||\n      length(K) != 1 ||\n      length(r) != 1 ||\n      length(q) != 1 ||\n      length(tt) != 1 ||\n      length(sigma) != 1 ||\n      length(steps) != 1\n  ) {\n    stop(\"All arguments must be scalar values\")\n  }\n\n  # Validate parameter ranges\n  if (S0 <= 0) {\n    stop(\"Initial stock price (S0) must be positive\")\n  }\n\n  if (K <= 0) {\n    stop(\"Strike price (K) must be positive\")\n  }\n\n  if (tt <= 0) {\n    stop(\"Time to maturity (tt) must be positive\")\n  }\n\n  if (sigma <= 0) {\n    stop(\"Volatility (sigma) must be positive\")\n  }\n\n  if (q < 0) {\n    stop(\"Dividend yield (q) must be non-negative\")\n  }\n\n  if (steps < 1) {\n    stop(\"Number of steps must be at least 1\")\n  }\n\n  # Check that steps is an integer\n  if (steps != floor(steps)) {\n    stop(\"Number of steps must be an integer\")\n  }\n\n  # Calculate risk-neutral probability for validation\n  dt <- tt / steps\n  u <- exp(sigma * sqrt(dt))\n  d <- exp(-sigma * sqrt(dt))\n  p <- (exp((r - q) * dt) - d) / (u - d)\n\n  # Validate risk-neutral probability (arbitrage-free condition)\n  if (p < 0 || p > 1) {\n    stop(sprintf(\n      \"Risk-neutral probability p=%.4f is outside [0,1]. Model parameters lead to arbitrage.\",\n      p\n    ))\n  }\n\n  # Check if C++ function needs to be compiled in this worker process\n  # Use an option to track compilation state per R session (worker)\n  if (is.null(getOption(\"ap_v3_cpp_compiled\"))) {\n    # Get absolute path to C++ file\n    cpp_file <- here::here(\"R\", \"ap_v3_rcpp.cpp\")\n\n    # Verify file exists\n    if (!file.exists(cpp_file)) {\n      stop(sprintf(\"C++ source file not found: %s\", cpp_file))\n    }\n\n    # Compile C++ source in this worker\n    tryCatch({\n      Rcpp::sourceCpp(cpp_file)\n      # Mark as compiled in this session\n      options(ap_v3_cpp_compiled = TRUE)\n    }, error = function(e) {\n      stop(sprintf(\"Failed to compile C++ source in worker: %s\", e$message))\n    })\n  }\n\n  # Verify the function is available\n  if (!exists(\"ap_v3_cpp\", mode = \"function\")) {\n    stop(\"C++ function ap_v3_cpp not found after compilation\")\n  }\n\n  # Call C++ implementation\n  return(ap_v3_cpp(S0, K, r, q, tt, sigma, steps))\n}\n```\n:::\n\n\n\n\n### `ap_v3_julia.R`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# R wrapper for Julia implementation of American put option pricing\n# Uses JuliaCall package to interface with Julia\n\n# Load required package\nif (!require(\"JuliaCall\", quietly = TRUE)) {\n  stop(\n    \"JuliaCall package is required. Install it with: install.packages('JuliaCall')\"\n  )\n}\n\n# Initialize Julia (only needs to be done once per session)\n# This function will set up the Julia connection\ninit_julia_ap <- function(num_threads = \"auto\") {\n  # Set the number of Julia threads before initialization\n  # Options: \"auto\" for all cores, or a specific number like \"8\"\n  Sys.setenv(JULIA_NUM_THREADS = as.character(num_threads))\n\n  # Initialize Julia\n  julia_setup()\n\n  # Use here package to reliably find the project root\n  if (!require(\"here\", quietly = TRUE)) {\n    stop(\"here package is required. Install it with: install.packages('here')\")\n  }\n\n  # Source the Julia file from the R directory\n  julia_file <- here::here(\"R\", \"ap_v3.jl\")\n\n  if (!file.exists(julia_file)) {\n    stop(paste(\"Julia file not found:\", julia_file))\n  }\n\n  julia_source(julia_file)\n\n  # Report thread count\n  nthreads <- julia_eval(\"Threads.nthreads()\")\n  message(sprintf(\"Julia initialized with %d threads and ap_v3.jl loaded successfully\", nthreads))\n}\n\n# R function that calls the Julia implementation\nap_v3_julia <- function(S0, K, r, q, tt, sigma, steps) {\n  # Basic input validation (Julia will do more thorough validation)\n  if (\n    missing(S0) ||\n      missing(K) ||\n      missing(r) ||\n      missing(q) ||\n      missing(tt) ||\n      missing(sigma) ||\n      missing(steps)\n  ) {\n    stop(\"All arguments must be provided\")\n  }\n\n  # Call the Julia function\n  result <- julia_call(\n    \"american_put_binomial\",\n    S0,\n    K,\n    r,\n    q,\n    tt,\n    sigma,\n    as.integer(steps)\n  )\n\n  return(result)\n}\n\n# Convenience function that combines initialization and execution\n# Use this if you want a single function call\nap_v3_julia_auto <- function(\n  S0,\n  K,\n  r,\n  q,\n  tt,\n  sigma,\n  steps,\n  force_reinit = FALSE\n) {\n  # Check if Julia is already initialized\n  if (!exists(\".julia_initialized\", envir = .GlobalEnv) || force_reinit) {\n    init_julia_ap()\n    assign(\".julia_initialized\", TRUE, envir = .GlobalEnv)\n  }\n\n  ap_v3_julia(S0, K, r, q, tt, sigma, steps)\n}\n\n# Vectorized batch function that processes multiple options in Julia using multi-threading\n# This is much more efficient than calling ap_v3_julia in a loop or using R parallelization\nap_v3_julia_batch <- function(S0, K, r, q, tt, sigma, steps) {\n  # Input validation - all vectors must have the same length\n  n <- length(S0)\n\n  if (length(K) != n || length(r) != n || length(q) != n ||\n      length(tt) != n || length(sigma) != n) {\n    stop(\"All parameter vectors must have the same length\")\n  }\n\n  # Handle steps - can be a single value or a vector\n  if (length(steps) == 1) {\n    steps <- rep(steps, n)\n  } else if (length(steps) != n) {\n    stop(\"steps must be either a single value or a vector of the same length as other parameters\")\n  }\n\n  # Call the Julia batch function\n  result <- julia_call(\n    \"american_put_binomial_batch\",\n    S0,\n    K,\n    r,\n    q,\n    tt,\n    sigma,\n    as.integer(steps)\n  )\n\n  return(result)\n}\n```\n:::\n\n\n\n# C++ Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\n// This is the C++ core implementation of the American put option pricing\n// algorithm using the Cox-Ross-Rubinstein binomial tree model.\n// It is designed to be called from R via the ap_v3_rcpp() wrapper function.\n\n#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble ap_v3_cpp(double S0, double K, double r, double q,\n                 double tt, double sigma, int steps) {\n  // S0: Initial stock price\n  // K: Strike price\n  // r: Risk-free interest rate compounded continuously\n  // q: Dividend yield compounded continuously\n  // tt: Time to maturity in years\n  // sigma: Volatility of the underlying stock\n  // steps: Number of time steps in the binomial tree\n\n  // Calculate binomial tree parameters\n  double dt = tt / steps;                          // Time between steps\n  double u = exp(sigma * sqrt(dt));                // Up factor\n  double d = exp(-sigma * sqrt(dt));               // Down factor\n  double p = (exp((r - q) * dt) - d) / (u - d);   // Risk-neutral probability\n  double disc = exp(-r * dt);                      // Discount factor\n\n  // Vector to store option values at each node\n  NumericVector option_values(steps + 1);\n\n  // Backward induction from maturity to root\n  // Note: C++ uses 0-based indexing, so j goes from steps to 0\n  for (int j = steps; j >= 0; j--) {\n    // Number of nodes at this time step\n    int num_nodes = (j == steps) ? (steps + 1) : (j + 1);\n\n    for (int i = 0; i < num_nodes; i++) {\n      // Calculate asset price at this node\n      // Formula: S0 * u^(j-i) * d^i\n      double asset_price = S0 * pow(u, j - i) * pow(d, i);\n\n      if (j == steps) {\n        // At maturity: option value is intrinsic value\n        option_values[i] = std::max(K - asset_price, 0.0);\n      } else {\n        // Before maturity: calculate continuation value and check early exercise\n        double continuation_value = (p * option_values[i] +\n                                    (1 - p) * option_values[i + 1]) * disc;\n        double intrinsic_value = K - asset_price;\n        option_values[i] = std::max(continuation_value, intrinsic_value);\n      }\n    }\n  }\n\n  // Return the option price at the root node\n  return option_values[0];\n}\n```\n:::\n\n\n\n# Julia Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# American Put Option Pricing using Binomial Tree\n# Julia implementation optimized for performance\n\n\"\"\"\n    american_put_binomial(S0, K, r, q, tt, sigma, steps)\n\nCalculate the price of an American put option using the Cox-Ross-Rubinstein binomial tree model.\n\n# Arguments\n- `S0::Real`: Initial stock price\n- `K::Real`: Strike price\n- `r::Real`: Risk-free interest rate (continuously compounded)\n- `q::Real`: Dividend yield (continuously compounded)\n- `tt::Real`: Time to maturity in years\n- `sigma::Real`: Volatility of the underlying stock\n- `steps::Integer`: Number of time steps in the binomial tree\n\n# Returns\n- `Float64`: Option price at the root node\n\"\"\"\nfunction american_put_binomial(S0::Real, K::Real, r::Real, q::Real,\n                                tt::Real, sigma::Real, steps::Integer)\n\n    # Input validation\n    S0 > 0 || throw(ArgumentError(\"Initial stock price (S0) must be positive\"))\n    K > 0 || throw(ArgumentError(\"Strike price (K) must be positive\"))\n    tt > 0 || throw(ArgumentError(\"Time to maturity (tt) must be positive\"))\n    sigma > 0 || throw(ArgumentError(\"Volatility (sigma) must be positive\"))\n    q >= 0 || throw(ArgumentError(\"Dividend yield (q) must be non-negative\"))\n    steps >= 1 || throw(ArgumentError(\"Number of steps must be at least 1\"))\n\n    # Calculate parameters\n    dt = tt / steps  # time between steps\n    u = exp(sigma * sqrt(dt))  # Up factor\n    d = exp(-sigma * sqrt(dt))  # Down factor\n    p = (exp((r - q) * dt) - d) / (u - d)  # Risk-neutral probability\n\n    # Validate risk-neutral probability (arbitrage-free condition)\n    if p < 0 || p > 1\n        throw(ArgumentError(\n            \"Risk-neutral probability p=$p is outside [0,1]. Model parameters lead to arbitrage.\"\n        ))\n    end\n\n    disc = exp(-r * dt)  # Discount factor\n\n    # Pre-allocate vector to store option values\n    option_values = Vector{Float64}(undef, steps + 1)\n\n    # Backward induction from maturity to root\n    for j in (steps + 1):-1:1\n        num_nodes = (j == steps + 1) ? steps + 1 : j\n\n        for i in 1:num_nodes\n            # Calculate asset price at this node\n            asset_price = S0 * u^(j - i) * d^(i - 1)\n\n            if j == steps + 1\n                # At maturity: option value is intrinsic value\n                option_values[i] = max(K - asset_price, 0.0)\n            else\n                # Before maturity: calculate continuation value and check early exercise\n                continuation_value = (p * option_values[i] +\n                                     (1 - p) * option_values[i + 1]) * disc\n                intrinsic_value = K - asset_price\n                option_values[i] = max(continuation_value, intrinsic_value)\n            end\n        end\n    end\n\n    return option_values[1]  # Option price at the root node\nend\n\n\"\"\"\n    american_put_binomial_batch(S0_vec, K_vec, r_vec, q_vec, tt_vec, sigma_vec, steps_vec)\n\nCalculate prices for multiple American put options using multi-threading.\nThis is much more efficient than calling american_put_binomial in a loop.\n\n# Arguments\nAll arguments should be vectors of the same length:\n- `S0_vec`: Vector of initial stock prices\n- `K_vec`: Vector of strike prices\n- `r_vec`: Vector of risk-free interest rates\n- `q_vec`: Vector of dividend yields\n- `tt_vec`: Vector of times to maturity\n- `sigma_vec`: Vector of volatilities\n- `steps_vec`: Vector of numbers of time steps\n\n# Returns\n- `Vector{Float64}`: Vector of option prices\n\"\"\"\nfunction american_put_binomial_batch(S0_vec::AbstractVector,\n                                     K_vec::AbstractVector,\n                                     r_vec::AbstractVector,\n                                     q_vec::AbstractVector,\n                                     tt_vec::AbstractVector,\n                                     sigma_vec::AbstractVector,\n                                     steps_vec::AbstractVector{<:Integer})\n    # Validate that all vectors have the same length\n    n = length(S0_vec)\n    if length(K_vec) != n || length(r_vec) != n || length(q_vec) != n ||\n       length(tt_vec) != n || length(sigma_vec) != n || length(steps_vec) != n\n        throw(ArgumentError(\"All input vectors must have the same length\"))\n    end\n\n    # Pre-allocate result vector\n    results = Vector{Float64}(undef, n)\n\n    # Use multi-threading to process options in parallel\n    Threads.@threads for i in 1:n\n        results[i] = american_put_binomial(\n            S0_vec[i],\n            K_vec[i],\n            r_vec[i],\n            q_vec[i],\n            tt_vec[i],\n            sigma_vec[i],\n            steps_vec[i]\n        )\n    end\n\n    return results\nend\n```\n:::\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}