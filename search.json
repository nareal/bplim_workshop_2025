[
  {
    "objectID": "r_package.html",
    "href": "r_package.html",
    "title": "R package",
    "section": "",
    "text": "The R package used to illustrate the advantages using compiled C++ code when parallelizing computations is available here.\nYou can install it directly from the tarball using the following command in R:\n\ninstall.packages(\"apopt_0.1.0.tar.gz\", repos = NULL, type = \"source\")\n\nInstalling package into '/Users/nareal/Library/R/arm64/4.5/library'\n(as 'lib' is unspecified)\n\n\nOnce installed, you can load the package and use the functions implemented in C++ as follows:\n\nlibrary(apopt)\n# Example usage of the C++ implemented function\namerican_put_value &lt;- ap_v3_rcpp(\n  S0 = 100,\n  K = 100,\n  r = 0.05,\n  q = 0.02,\n  tt = 1,\n  sigma = 0.2,\n  steps = 1000\n)\n\nprint(american_put_value)\n\n[1] 6.659759",
    "crumbs": [
      "Home",
      "R package"
    ]
  },
  {
    "objectID": "notebooks/01-create_option_parameters.html",
    "href": "notebooks/01-create_option_parameters.html",
    "title": "Create a options sample parameters dataset",
    "section": "",
    "text": "library(tibble)\nlibrary(here)\n\nCreate a 2500 sample of options parameters to test the binomial tree algorithms.\nSample volatility (\\(\\sigma\\)) is distributed uniformly between 0.1 and 0.6, time-to-maturity (\\(T\\)) is uniform between 0.1 and 1.0 year with probability 0.75, and uniform between 1.0 and 5.0 years with probability 0.25. The asset price (\\(S_0\\)) follows a uniform distribution between 70 and 130. The dividend rate (\\(q\\)) is uniform between 0.0 and 0.1. The riskless interest rate (\\(r\\)) is uniform between 0.0 and 0.1, with probability 0.8, and with probability 0.2 equal to 0.0. Because only the ratio between asset price and exercise price (\\(K\\)) is of interest, since relative errors do not change if \\(S\\) and \\(K\\) are scaled by the same factor, the exercise price is fixed to 100.0.\n\nset.seed(42)\nn &lt;- 2500\n\noption_parameters &lt;- tibble(\n  option_set = 1:n,\n  volatility = runif(n, 0.1, 0.6),\n  time_to_maturity = ifelse(\n    runif(n) &lt; 0.75,\n    runif(n, 0.1, 1.0),\n    runif(n, 1.0, 5.0)\n  ),\n  asset_price = runif(n, 70, 130),\n  dividend_rate = runif(n, 0.0, 0.1),\n  riskless_rate = ifelse(runif(n) &lt; 0.8, runif(n, 0.0, 0.1), 0.0),\n  exercise_price = rep(100.0, n)\n)\n\nsaveRDS(option_parameters, here(\"data\", \"processed\", \"option_parameters.rds\"))",
    "crumbs": [
      "Home",
      "Notebooks",
      "Create option parameters - Test suite"
    ]
  },
  {
    "objectID": "code.html",
    "href": "code.html",
    "title": "R, C++ and Julia code",
    "section": "",
    "text": "You can find below the functions implemented in R, C++ and Julia.",
    "crumbs": [
      "Home",
      "R, C++ and Julia code"
    ]
  },
  {
    "objectID": "code.html#different-implementations-of-american-put-option-using-binomial-trees",
    "href": "code.html#different-implementations-of-american-put-option-using-binomial-trees",
    "title": "R, C++ and Julia code",
    "section": "1.1 Different implementations of american put option using binomial trees",
    "text": "1.1 Different implementations of american put option using binomial trees\n\n1.1.1 ap_naive.R\n\n# This function implements a bionomial tree algorithm for\n# valuing American put options using Cox-Ross-Rubinstein parameters.\n\nap_naive &lt;- function(S0, K, r, q, tt, sigma, steps) {\n  # S0: Initial stock price\n  # K: Strike price\n  # r: Risk-free interest rate compounded continuously\n  # q: Dividend yield compounded continuously\n  # tt: Time to maturity in years\n  # sigma: Volatility of the underlying stock\n  # steps: Number of time steps in the binomial tree\n\n  dt &lt;- tt / steps # time between steps\n  u &lt;- exp(sigma * sqrt(dt)) # Up factor\n  d &lt;- exp(-sigma * sqrt(dt)) # Down factor\n  p &lt;- (exp((r - q) * dt) - d) / (u - d) # Risk-neutral probability\n\n  # Initialize matrices for asset prices and option values\n  # Rows represent nodes (i), columns represent time steps (j)\n  asset_prices &lt;- matrix(NA, nrow = steps + 1, ncol = steps + 1)\n  option_values &lt;- matrix(NA, nrow = steps + 1, ncol = steps + 1)\n\n  # Fill in asset prices for all nodes in the tree (lower triangular)\n  for (j in 1:(steps + 1)) {\n    for (i in (steps + 2 - j):(steps + 1)) {\n      asset_prices[i, j] &lt;- S0 * u^(steps + 1 - i) * d^(i + j - steps - 2)\n    }\n  }\n\n  # Initialize option values at maturity (last column)\n  for (i in 1:(steps + 1)) {\n    option_values[i, steps + 1] &lt;- max(K - asset_prices[i, steps + 1], 0)\n  }\n\n  # Backward induction to calculate option price at earlier nodes\n  # i - node, j - time step\n  for (j in steps:1) {\n    for (i in (steps + 2 - j):(steps + 1)) {\n      # Calculate continuation value\n      option_values[i, j] &lt;-\n        (p * option_values[i - 1, j + 1] + (1 - p) * option_values[i, j + 1]) *\n        exp(-r * dt)\n\n      # Check for early exercise\n      intrinsic_value &lt;- K - asset_prices[i, j]\n      option_values[i, j] &lt;- max(option_values[i, j], intrinsic_value)\n    }\n  }\n\n  return(option_values[steps + 1, 1]) # Option price at the root node\n}\n\n\n\n1.1.2 ap_v1.R\n\n# This function implements an optimized binomial tree algorithm for\n# valuing American put options using Cox-Ross-Rubinstein parameters.\n# Optimization:\n# Uses vectors instead of matrices and calculates asset prices on the fly.\n\nap_v1 &lt;- function(S0, K, r, q, tt, sigma, steps) {\n  # S0: Initial stock price\n  # K: Strike price\n  # r: Risk-free interest rate compounded continuously\n  # q: Dividend yield compounded continuously\n  # tt: Time to maturity in years\n  # sigma: Volatility of the underlying stock\n  # steps: Number of time steps in the binomial tree\n\n  dt &lt;- tt / steps # time between steps\n  u &lt;- exp(sigma * sqrt(dt)) # Up factor\n  d &lt;- exp(-sigma * sqrt(dt)) # Down factor\n  p &lt;- (exp((r - q) * dt) - d) / (u - d) # Risk-neutral probability\n  disc &lt;- exp(-r * dt) # Discount factor\n\n  # Initialize option values at maturity\n  # Vector size is steps + 1 (for nodes 0 to steps)\n  option_values &lt;- numeric(steps + 1)\n\n  # Calculate option values at maturity\n  for (i in 1:(steps + 1)) {\n    # At maturity, node i has (steps + 1 - i) up moves and (i - 1) down moves\n    asset_price &lt;- S0 * u^(steps + 1 - i) * d^(i - 1)\n    option_values[i] &lt;- max(K - asset_price, 0)\n  }\n\n  # Backward induction to calculate option price at earlier nodes\n  for (j in steps:1) {\n    # At time step j, we have j nodes\n    for (i in 1:j) {\n      # Calculate continuation value\n      option_values[i] &lt;- (p *\n        option_values[i] +\n        (1 - p) * option_values[i + 1]) *\n        disc\n\n      # Calculate asset price for early exercise check\n      # At time step j-1, node i has (j - i) up moves and (i - 1) down moves\n      asset_price &lt;- S0 * u^(j - i) * d^(i - 1)\n\n      # Check for early exercise\n      intrinsic_value &lt;- K - asset_price\n      option_values[i] &lt;- max(option_values[i], intrinsic_value)\n    }\n  }\n\n  return(option_values[1]) # Option price at the root node\n}\n\n\n\n1.1.3 ap_v2.R\n\n# This function implements an optimized binomial tree algorithm for\n# valuing American put options using Cox-Ross-Rubinstein parameters.\n# Optimization:\n# Uses vectors instead of matrices and calculates asset prices on the fly\n# and removes one loop in relation to ap_v1.\n\nap_v2 &lt;- function(S0, K, r, q, tt, sigma, steps) {\n  # S0: Initial stock price\n  # K: Strike price\n  # r: Risk-free interest rate compounded continuously\n  # q: Dividend yield compounded continuously\n  # tt: Time to maturity in years\n  # sigma: Volatility of the underlying stock\n  # steps: Number of time steps in the binomial tree\n\n  dt &lt;- tt / steps # time between steps\n  u &lt;- exp(sigma * sqrt(dt)) # Up factor\n  d &lt;- exp(-sigma * sqrt(dt)) # Down factor\n  p &lt;- (exp((r - q) * dt) - d) / (u - d) # Risk-neutral probability\n  disc &lt;- exp(-r * dt) # Discount factor\n\n  # Vector to store option values\n  option_values &lt;- numeric(steps + 1)\n\n  # Backward induction from maturity to root\n  for (j in (steps + 1):1) {\n    num_nodes &lt;- if (j == steps + 1) steps + 1 else j\n\n    for (i in 1:num_nodes) {\n      # Calculate asset price at this node\n      asset_price &lt;- S0 * u^(j - i) * d^(i - 1)\n\n      if (j == steps + 1) {\n        # At maturity: option value is intrinsic value\n        option_values[i] &lt;- max(K - asset_price, 0)\n      } else {\n        # Before maturity: calculate continuation value and check early exercise\n        continuation_value &lt;- (p *\n          option_values[i] +\n          (1 - p) * option_values[i + 1]) *\n          disc\n        intrinsic_value &lt;- K - asset_price\n        option_values[i] &lt;- max(continuation_value, intrinsic_value)\n      }\n    }\n  }\n\n  return(option_values[1]) # Option price at the root node\n}\n\n\n\n1.1.4 ap_v3.R\n\n# This function implements an optimized binomial tree algorithm for\n# valuing American put options using Cox-Ross-Rubinstein parameters.\n# In relation to ap_v2 includes defensive programming with input validation.\n\nap_v3 &lt;- function(S0, K, r, q, tt, sigma, steps) {\n  # S0: Initial stock price\n  # K: Strike price\n  # r: Risk-free interest rate compounded continuously\n  # q: Dividend yield compounded continuously\n  # tt: Time to maturity in years\n  # sigma: Volatility of the underlying stock\n  # steps: Number of time steps in the binomial tree\n\n  # Input validation\n  # Check for missing arguments\n  if (\n    missing(S0) ||\n      missing(K) ||\n      missing(r) ||\n      missing(q) ||\n      missing(tt) ||\n      missing(sigma) ||\n      missing(steps)\n  ) {\n    stop(\"All arguments must be provided\")\n  }\n\n  # Check for NA or NULL values\n  if (\n    any(is.na(c(S0, K, r, q, tt, sigma, steps))) ||\n      any(is.null(c(S0, K, r, q, tt, sigma, steps)))\n  ) {\n    stop(\"Arguments cannot be NA or NULL\")\n  }\n\n  # Check that all inputs are numeric\n  if (\n    !is.numeric(S0) ||\n      !is.numeric(K) ||\n      !is.numeric(r) ||\n      !is.numeric(q) ||\n      !is.numeric(tt) ||\n      !is.numeric(sigma) ||\n      !is.numeric(steps)\n  ) {\n    stop(\"All arguments must be numeric\")\n  }\n\n  # Check that inputs are scalar (length 1)\n  if (\n    length(S0) != 1 ||\n      length(K) != 1 ||\n      length(r) != 1 ||\n      length(q) != 1 ||\n      length(tt) != 1 ||\n      length(sigma) != 1 ||\n      length(steps) != 1\n  ) {\n    stop(\"All arguments must be scalar values\")\n  }\n\n  # Validate parameter ranges\n  if (S0 &lt;= 0) {\n    stop(\"Initial stock price (S0) must be positive\")\n  }\n\n  if (K &lt;= 0) {\n    stop(\"Strike price (K) must be positive\")\n  }\n\n  if (tt &lt;= 0) {\n    stop(\"Time to maturity (tt) must be positive\")\n  }\n\n  if (sigma &lt;= 0) {\n    stop(\"Volatility (sigma) must be positive\")\n  }\n\n  if (q &lt; 0) {\n    stop(\"Dividend yield (q) must be non-negative\")\n  }\n\n  if (steps &lt; 1) {\n    stop(\"Number of steps must be at least 1\")\n  }\n\n  # Check that steps is an integer\n  if (steps != floor(steps)) {\n    stop(\"Number of steps must be an integer\")\n  }\n\n  # Calculate parameters\n  dt &lt;- tt / steps # time between steps\n  u &lt;- exp(sigma * sqrt(dt)) # Up factor\n  d &lt;- exp(-sigma * sqrt(dt)) # Down factor\n  p &lt;- (exp((r - q) * dt) - d) / (u - d) # Risk-neutral probability\n\n  # Validate risk-neutral probability (arbitrage-free condition)\n  if (p &lt; 0 || p &gt; 1) {\n    stop(sprintf(\n      \"Risk-neutral probability p=%.4f is outside [0,1]. Model parameters lead to arbitrage.\",\n      p\n    ))\n  }\n\n  disc &lt;- exp(-r * dt) # Discount factor\n\n  # Vector to store option values\n  option_values &lt;- numeric(steps + 1)\n\n  # Backward induction from maturity to root\n  for (j in (steps + 1):1) {\n    num_nodes &lt;- if (j == steps + 1) steps + 1 else j\n\n    for (i in 1:num_nodes) {\n      # Calculate asset price at this node\n      asset_price &lt;- S0 * u^(j - i) * d^(i - 1)\n\n      if (j == steps + 1) {\n        # At maturity: option value is intrinsic value\n        option_values[i] &lt;- max(K - asset_price, 0)\n      } else {\n        # Before maturity: calculate continuation value and check early exercise\n        continuation_value &lt;- (p *\n          option_values[i] +\n          (1 - p) * option_values[i + 1]) *\n          disc\n        intrinsic_value &lt;- K - asset_price\n        option_values[i] &lt;- max(continuation_value, intrinsic_value)\n      }\n    }\n  }\n\n  return(option_values[1]) # Option price at the root node\n}\n\n\n\n1.1.5 ap_v3_torch.R\n\n# Load required package\nif (!require(\"torch\", quietly = TRUE)) {\n  stop(\n    \"torch package is required. Install it with: install.packages('torch')\"\n  )\n}\n\n#' Price multiple American put options using a batched binomial tree on a GPU.\n#'\n#' This function extends the scalar CRR binomial tree implementation so that many\n#' put option contracts can be priced simultaneously. The binomial time recursion\n#' remains sequential, but each level operates on the entire batch, allowing the\n#' GPU to process wide workloads efficiently. All contracts share the same\n#' number of time steps \\code{steps}; other parameters may vary by contract.\n#'\n#' @param S0 Numeric vector of initial stock prices.\n#' @param K Numeric vector of strike prices.\n#' @param r Numeric vector of continuously compounded risk-free rates.\n#' @param q Numeric vector of dividend yields compounded continuously.\n#' @param sigma Numeric vector of volatilities.\n#' @param tt Numeric vector of times to maturity (years).\n#' @param steps Integer scalar with the number of binomial steps (shared by batch).\n#'\n#' @return Numeric vector of American put option prices, one per contract.\nap_v3_torch &lt;- function(S0, K, r, q, tt, sigma, steps) {\n  # --- 1. Device and dtype selection ----------------------------------------------------------\n  if (torch::cuda_is_available()) {\n    device &lt;- \"cuda\"\n    float_dtype &lt;- torch_double()\n    message(\"CUDA device detected. Using torch_double() (float64).\")\n  } else if (torch::backends_mps_is_available()) {\n    device &lt;- \"mps\"\n    float_dtype &lt;- torch_float()\n    message(\"MPS device detected. Using torch_float() (float32).\")\n  } else {\n    stop(\"No compatible GPU (CUDA or MPS) available.\")\n  }\n\n  # --- 2. Input validation and broadcasting ---------------------------------------------------\n  if (length(steps) != 1) {\n    stop(\"`steps` must be a single integer shared by the batch.\")\n  }\n  steps &lt;- as.integer(steps)\n  if (steps &lt;= 0) {\n    stop(\"`steps` must be a positive integer.\")\n  }\n\n  lengths &lt;- c(\n    length(S0),\n    length(K),\n    length(r),\n    length(q),\n    length(sigma),\n    length(tt)\n  )\n  if (any(lengths == 0)) {\n    stop(\"All parameters must have at least one value.\")\n  }\n  batch &lt;- max(lengths)\n\n  broadcast_param &lt;- function(x, name) {\n    if (length(x) == 1) {\n      rep(x, batch)\n    } else if (length(x) == batch) {\n      x\n    } else {\n      stop(sprintf(\n        \"`%s` must have length 1 or match the batch size (%d).\",\n        name,\n        batch\n      ))\n    }\n  }\n\n  S0_vec &lt;- as.numeric(broadcast_param(S0, \"S0\"))\n  K_vec &lt;- as.numeric(broadcast_param(K, \"K\"))\n  r_vec &lt;- as.numeric(broadcast_param(r, \"r\"))\n  q_vec &lt;- as.numeric(broadcast_param(q, \"q\"))\n  sigma_vec &lt;- as.numeric(broadcast_param(sigma, \"sigma\"))\n  tt_vec &lt;- as.numeric(broadcast_param(tt, \"tt\"))\n\n  dt_vec &lt;- tt_vec / steps\n  if (any(dt_vec &lt;= 0)) {\n    stop(\"All maturities must be positive.\")\n  }\n\n  u_vec &lt;- exp(sigma_vec * sqrt(dt_vec))\n  d_vec &lt;- 1 / u_vec\n  denom &lt;- u_vec - d_vec\n  if (any(abs(denom) &lt; .Machine$double.eps)) {\n    stop(\"Encountered zero denominator in probability computation.\")\n  }\n  p_vec &lt;- (exp((r_vec - q_vec) * dt_vec) - d_vec) / denom\n  if (any(p_vec &lt; 0 | p_vec &gt; 1)) {\n    stop(\"Risk-neutral probability out of bounds; check inputs.\")\n  }\n  down_prob_vec &lt;- 1 - p_vec\n  df_vec &lt;- exp(-r_vec * dt_vec)\n\n  # --- 3. Promote scalars to batched GPU tensors ----------------------------------------------\n  S0_t &lt;- torch_tensor(S0_vec, device = device, dtype = float_dtype)$view(c(\n    batch,\n    1,\n    1\n  ))\n  K_t &lt;- torch_tensor(K_vec, device = device, dtype = float_dtype)$view(c(\n    batch,\n    1,\n    1\n  ))\n  u_t &lt;- torch_tensor(u_vec, device = device, dtype = float_dtype)$view(c(\n    batch,\n    1,\n    1\n  ))\n  d_t &lt;- torch_tensor(d_vec, device = device, dtype = float_dtype)$view(c(\n    batch,\n    1,\n    1\n  ))\n  p_line &lt;- torch_tensor(p_vec, device = device, dtype = float_dtype)$view(c(\n    batch,\n    1,\n    1\n  ))\n  down_prob_line &lt;- torch_tensor(\n    down_prob_vec,\n    device = device,\n    dtype = float_dtype\n  )$view(c(batch, 1, 1))\n  df_line &lt;- torch_tensor(df_vec, device = device, dtype = float_dtype)$view(c(\n    batch,\n    1,\n    1\n  ))\n  zero_scalar &lt;- torch_tensor(0, device = device, dtype = float_dtype)\n\n  # --- 4. Precompute stock prices and exercise values (batched) -------------------------------\n  j_seq &lt;- torch_tensor(0:steps, device = device, dtype = float_dtype)\n  j_indices &lt;- j_seq$view(c(1, steps + 1, 1))\n  n_seq &lt;- torch_tensor(0:steps, device = device, dtype = float_dtype)\n  n_indices &lt;- n_seq$view(c(1, 1, steps + 1))\n\n  S_all &lt;- S0_t * (u_t$pow(j_indices)) * (d_t$pow(n_indices - j_indices))\n\n  # Compute put payoffs: max(K - S, 0)\n  ex_all &lt;- torch_maximum(K_t - S_all, zero_scalar)\n\n  # --- 5. Backward induction across the batch -------------------------------------------------\n  V &lt;- ex_all$narrow(3, steps + 1, 1)\n\n  for (n in (steps - 1):0) {\n    n_nodes &lt;- n + 1\n\n    V_up &lt;- V$narrow(2, 2, n_nodes)\n    V_down &lt;- V$narrow(2, 1, n_nodes)\n    V_hold &lt;- df_line * (p_line * V_up + down_prob_line * V_down)\n\n    V_ex &lt;- ex_all$narrow(2, 1, n_nodes)$narrow(3, n + 1, 1)\n    V &lt;- torch_maximum(V_hold, V_ex)\n  }\n\n  # --- 6. Return one price per contract -------------------------------------------------------\n  as.numeric(V$squeeze())\n}",
    "crumbs": [
      "Home",
      "R, C++ and Julia code"
    ]
  },
  {
    "objectID": "code.html#r-wrappers-to-call-c-and-julia-implementations",
    "href": "code.html#r-wrappers-to-call-c-and-julia-implementations",
    "title": "R, C++ and Julia code",
    "section": "1.2 R wrappers to call C++ and Julia implementations",
    "text": "1.2 R wrappers to call C++ and Julia implementations\n\n1.2.1 ap_v3_rcpp.R\n\n# This function wraps the C++ implementation (ap_v3_cpp) with R-based input\n# validation. It provides the same interface as ap_v3 with improved performance.\n# The validation code is identical to ap_v3 to ensure the same error checking.\n\nap_v3_rcpp &lt;- function(S0, K, r, q, tt, sigma, steps) {\n  # S0: Initial stock price\n  # K: Strike price\n  # r: Risk-free interest rate compounded continuously\n  # q: Dividend yield compounded continuously\n  # tt: Time to maturity in years\n  # sigma: Volatility of the underlying stock\n  # steps: Number of time steps in the binomial tree\n\n  # Input validation\n  # Check for missing arguments\n  if (\n    missing(S0) ||\n      missing(K) ||\n      missing(r) ||\n      missing(q) ||\n      missing(tt) ||\n      missing(sigma) ||\n      missing(steps)\n  ) {\n    stop(\"All arguments must be provided\")\n  }\n\n  # Check for NA or NULL values\n  if (\n    any(is.na(c(S0, K, r, q, tt, sigma, steps))) ||\n      any(is.null(c(S0, K, r, q, tt, sigma, steps)))\n  ) {\n    stop(\"Arguments cannot be NA or NULL\")\n  }\n\n  # Check that all inputs are numeric\n  if (\n    !is.numeric(S0) ||\n      !is.numeric(K) ||\n      !is.numeric(r) ||\n      !is.numeric(q) ||\n      !is.numeric(tt) ||\n      !is.numeric(sigma) ||\n      !is.numeric(steps)\n  ) {\n    stop(\"All arguments must be numeric\")\n  }\n\n  # Check that inputs are scalar (length 1)\n  if (\n    length(S0) != 1 ||\n      length(K) != 1 ||\n      length(r) != 1 ||\n      length(q) != 1 ||\n      length(tt) != 1 ||\n      length(sigma) != 1 ||\n      length(steps) != 1\n  ) {\n    stop(\"All arguments must be scalar values\")\n  }\n\n  # Validate parameter ranges\n  if (S0 &lt;= 0) {\n    stop(\"Initial stock price (S0) must be positive\")\n  }\n\n  if (K &lt;= 0) {\n    stop(\"Strike price (K) must be positive\")\n  }\n\n  if (tt &lt;= 0) {\n    stop(\"Time to maturity (tt) must be positive\")\n  }\n\n  if (sigma &lt;= 0) {\n    stop(\"Volatility (sigma) must be positive\")\n  }\n\n  if (q &lt; 0) {\n    stop(\"Dividend yield (q) must be non-negative\")\n  }\n\n  if (steps &lt; 1) {\n    stop(\"Number of steps must be at least 1\")\n  }\n\n  # Check that steps is an integer\n  if (steps != floor(steps)) {\n    stop(\"Number of steps must be an integer\")\n  }\n\n  # Calculate risk-neutral probability for validation\n  dt &lt;- tt / steps\n  u &lt;- exp(sigma * sqrt(dt))\n  d &lt;- exp(-sigma * sqrt(dt))\n  p &lt;- (exp((r - q) * dt) - d) / (u - d)\n\n  # Validate risk-neutral probability (arbitrage-free condition)\n  if (p &lt; 0 || p &gt; 1) {\n    stop(sprintf(\n      \"Risk-neutral probability p=%.4f is outside [0,1]. Model parameters lead to arbitrage.\",\n      p\n    ))\n  }\n\n  # Call C++ implementation\n  return(ap_v3_cpp(S0, K, r, q, tt, sigma, steps))\n}\n\n\n\n1.2.2 ap_v3_rcpp_par.R\n\n# This function wraps the C++ implementation (ap_v3_cpp) with R-based input\n# validation. It provides the same interface as ap_v3 with improved performance.\n# The validation code is identical to ap_v3 to ensure the same error checking.\n\nap_v3_rcpp_par &lt;- function(S0, K, r, q, tt, sigma, steps) {\n  # S0: Initial stock price\n  # K: Strike price\n  # r: Risk-free interest rate compounded continuously\n  # q: Dividend yield compounded continuously\n  # tt: Time to maturity in years\n  # sigma: Volatility of the underlying stock\n  # steps: Number of time steps in the binomial tree\n\n  # Input validation\n  # Check for missing arguments\n  if (\n    missing(S0) ||\n      missing(K) ||\n      missing(r) ||\n      missing(q) ||\n      missing(tt) ||\n      missing(sigma) ||\n      missing(steps)\n  ) {\n    stop(\"All arguments must be provided\")\n  }\n\n  # Check for NA or NULL values\n  if (\n    any(is.na(c(S0, K, r, q, tt, sigma, steps))) ||\n      any(is.null(c(S0, K, r, q, tt, sigma, steps)))\n  ) {\n    stop(\"Arguments cannot be NA or NULL\")\n  }\n\n  # Check that all inputs are numeric\n  if (\n    !is.numeric(S0) ||\n      !is.numeric(K) ||\n      !is.numeric(r) ||\n      !is.numeric(q) ||\n      !is.numeric(tt) ||\n      !is.numeric(sigma) ||\n      !is.numeric(steps)\n  ) {\n    stop(\"All arguments must be numeric\")\n  }\n\n  # Check that inputs are scalar (length 1)\n  if (\n    length(S0) != 1 ||\n      length(K) != 1 ||\n      length(r) != 1 ||\n      length(q) != 1 ||\n      length(tt) != 1 ||\n      length(sigma) != 1 ||\n      length(steps) != 1\n  ) {\n    stop(\"All arguments must be scalar values\")\n  }\n\n  # Validate parameter ranges\n  if (S0 &lt;= 0) {\n    stop(\"Initial stock price (S0) must be positive\")\n  }\n\n  if (K &lt;= 0) {\n    stop(\"Strike price (K) must be positive\")\n  }\n\n  if (tt &lt;= 0) {\n    stop(\"Time to maturity (tt) must be positive\")\n  }\n\n  if (sigma &lt;= 0) {\n    stop(\"Volatility (sigma) must be positive\")\n  }\n\n  if (q &lt; 0) {\n    stop(\"Dividend yield (q) must be non-negative\")\n  }\n\n  if (steps &lt; 1) {\n    stop(\"Number of steps must be at least 1\")\n  }\n\n  # Check that steps is an integer\n  if (steps != floor(steps)) {\n    stop(\"Number of steps must be an integer\")\n  }\n\n  # Calculate risk-neutral probability for validation\n  dt &lt;- tt / steps\n  u &lt;- exp(sigma * sqrt(dt))\n  d &lt;- exp(-sigma * sqrt(dt))\n  p &lt;- (exp((r - q) * dt) - d) / (u - d)\n\n  # Validate risk-neutral probability (arbitrage-free condition)\n  if (p &lt; 0 || p &gt; 1) {\n    stop(sprintf(\n      \"Risk-neutral probability p=%.4f is outside [0,1]. Model parameters lead to arbitrage.\",\n      p\n    ))\n  }\n\n  # Check if C++ function needs to be compiled in this worker process\n  # Use an option to track compilation state per R session (worker)\n  if (is.null(getOption(\"ap_v3_cpp_compiled\"))) {\n    # Get absolute path to C++ file\n    cpp_file &lt;- here::here(\"R\", \"ap_v3_rcpp.cpp\")\n\n    # Verify file exists\n    if (!file.exists(cpp_file)) {\n      stop(sprintf(\"C++ source file not found: %s\", cpp_file))\n    }\n\n    # Compile C++ source in this worker\n    tryCatch({\n      Rcpp::sourceCpp(cpp_file)\n      # Mark as compiled in this session\n      options(ap_v3_cpp_compiled = TRUE)\n    }, error = function(e) {\n      stop(sprintf(\"Failed to compile C++ source in worker: %s\", e$message))\n    })\n  }\n\n  # Verify the function is available\n  if (!exists(\"ap_v3_cpp\", mode = \"function\")) {\n    stop(\"C++ function ap_v3_cpp not found after compilation\")\n  }\n\n  # Call C++ implementation\n  return(ap_v3_cpp(S0, K, r, q, tt, sigma, steps))\n}\n\n\n\n1.2.3 ap_v3_julia.R\n\n# R wrapper for Julia implementation of American put option pricing\n# Uses JuliaCall package to interface with Julia\n\n# Load required package\nif (!require(\"JuliaCall\", quietly = TRUE)) {\n  stop(\n    \"JuliaCall package is required. Install it with: install.packages('JuliaCall')\"\n  )\n}\n\n# Initialize Julia (only needs to be done once per session)\n# This function will set up the Julia connection\ninit_julia_ap &lt;- function(num_threads = \"auto\") {\n  # Set the number of Julia threads before initialization\n  # Options: \"auto\" for all cores, or a specific number like \"8\"\n  Sys.setenv(JULIA_NUM_THREADS = as.character(num_threads))\n\n  # Initialize Julia\n  julia_setup()\n\n  # Use here package to reliably find the project root\n  if (!require(\"here\", quietly = TRUE)) {\n    stop(\"here package is required. Install it with: install.packages('here')\")\n  }\n\n  # Source the Julia file from the R directory\n  julia_file &lt;- here::here(\"R\", \"ap_v3.jl\")\n\n  if (!file.exists(julia_file)) {\n    stop(paste(\"Julia file not found:\", julia_file))\n  }\n\n  julia_source(julia_file)\n\n  # Report thread count\n  nthreads &lt;- julia_eval(\"Threads.nthreads()\")\n  message(sprintf(\"Julia initialized with %d threads and ap_v3.jl loaded successfully\", nthreads))\n}\n\n# R function that calls the Julia implementation\nap_v3_julia &lt;- function(S0, K, r, q, tt, sigma, steps) {\n  # Basic input validation (Julia will do more thorough validation)\n  if (\n    missing(S0) ||\n      missing(K) ||\n      missing(r) ||\n      missing(q) ||\n      missing(tt) ||\n      missing(sigma) ||\n      missing(steps)\n  ) {\n    stop(\"All arguments must be provided\")\n  }\n\n  # Call the Julia function\n  result &lt;- julia_call(\n    \"american_put_binomial\",\n    S0,\n    K,\n    r,\n    q,\n    tt,\n    sigma,\n    as.integer(steps)\n  )\n\n  return(result)\n}\n\n# Convenience function that combines initialization and execution\n# Use this if you want a single function call\nap_v3_julia_auto &lt;- function(\n  S0,\n  K,\n  r,\n  q,\n  tt,\n  sigma,\n  steps,\n  force_reinit = FALSE\n) {\n  # Check if Julia is already initialized\n  if (!exists(\".julia_initialized\", envir = .GlobalEnv) || force_reinit) {\n    init_julia_ap()\n    assign(\".julia_initialized\", TRUE, envir = .GlobalEnv)\n  }\n\n  ap_v3_julia(S0, K, r, q, tt, sigma, steps)\n}\n\n# Vectorized batch function that processes multiple options in Julia using multi-threading\n# This is much more efficient than calling ap_v3_julia in a loop or using R parallelization\nap_v3_julia_batch &lt;- function(S0, K, r, q, tt, sigma, steps) {\n  # Input validation - all vectors must have the same length\n  n &lt;- length(S0)\n\n  if (length(K) != n || length(r) != n || length(q) != n ||\n      length(tt) != n || length(sigma) != n) {\n    stop(\"All parameter vectors must have the same length\")\n  }\n\n  # Handle steps - can be a single value or a vector\n  if (length(steps) == 1) {\n    steps &lt;- rep(steps, n)\n  } else if (length(steps) != n) {\n    stop(\"steps must be either a single value or a vector of the same length as other parameters\")\n  }\n\n  # Call the Julia batch function\n  result &lt;- julia_call(\n    \"american_put_binomial_batch\",\n    S0,\n    K,\n    r,\n    q,\n    tt,\n    sigma,\n    as.integer(steps)\n  )\n\n  return(result)\n}",
    "crumbs": [
      "Home",
      "R, C++ and Julia code"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "BPlim workshop 2025",
    "section": "",
    "text": "This hands-on workshop demonstrates practical strategies for accelerating computational workflows in empirical research. Participants will learn a systematic approach to performance optimization, beginning with a naive R implementation and progressively applying multiple acceleration techniques. The session covers: (1) native R optimization strategies, (2) integrating C++ via Rcpp, (3) leveraging Julia for high-performance computing, (4) implementing parallelization within R, (5) utilizing GPU acceleration with torch, and (6) scaling to cluster computing for horizontal parallelism. Each approach includes implementation, testing, error handling, and benchmarking to quantify performance gains. The workshop also demonstrates how AI-assisted coding tools can facilitate cross-language development and code optimization. Attendees will leave with a practical framework for identifying performance bottlenecks and selecting appropriate optimization strategies for their computational research needs.\n\n\n\n\n\n\nImportantDisclaimer\n\n\n\nThe content presented is for educational purposes only and reflects the views of the instructors. Users should independently verify and validate any techniques or tools discussed before applying them to their own work."
  },
  {
    "objectID": "index.html#abstract",
    "href": "index.html#abstract",
    "title": "BPlim workshop 2025",
    "section": "",
    "text": "This hands-on workshop demonstrates practical strategies for accelerating computational workflows in empirical research. Participants will learn a systematic approach to performance optimization, beginning with a naive R implementation and progressively applying multiple acceleration techniques. The session covers: (1) native R optimization strategies, (2) integrating C++ via Rcpp, (3) leveraging Julia for high-performance computing, (4) implementing parallelization within R, (5) utilizing GPU acceleration with torch, and (6) scaling to cluster computing for horizontal parallelism. Each approach includes implementation, testing, error handling, and benchmarking to quantify performance gains. The workshop also demonstrates how AI-assisted coding tools can facilitate cross-language development and code optimization. Attendees will leave with a practical framework for identifying performance bottlenecks and selecting appropriate optimization strategies for their computational research needs.\n\n\n\n\n\n\nImportantDisclaimer\n\n\n\nThe content presented is for educational purposes only and reflects the views of the instructors. Users should independently verify and validate any techniques or tools discussed before applying them to their own work."
  },
  {
    "objectID": "notebooks/02-benchmark.html",
    "href": "notebooks/02-benchmark.html",
    "title": "Benchmarking American Put option pricing algorithms",
    "section": "",
    "text": "Load the libraries and source the functions.\nlibrary(tidyverse)\nlibrary(bench)\nlibrary(furrr)\nlibrary(Rcpp)\nlibrary(JuliaCall)\nlibrary(torch)\nlibrary(here)\nlibrary(apopt) # Our package with pre-compiled Rcpp code\n\nsource(here(\"R\", \"ap_naive.R\"))\nsource(here(\"R\", \"ap_v1.R\"))\nsource(here(\"R\", \"ap_v2.R\"))\nsource(here(\"R\", \"ap_v3.R\"))\n# For comparison, we still source the Rcpp implementation without the package\nRcpp::sourceCpp(here(\"R\", \"ap_v3_rcpp.cpp\"))\nsource(here(\"R\", \"ap_v3_rcpp.R\"))\nsource(here(\"R\", \"ap_v3_rcpp_par.R\"))\nsource(here(\"R\", \"ap_v3_julia.R\"))\nsource(here(\"R\", \"ap_v3_torch.R\"))",
    "crumbs": [
      "Home",
      "Notebooks",
      "Benchmarking different implementations"
    ]
  },
  {
    "objectID": "notebooks/02-benchmark.html#benchmark-single-option-pricing-with-different-r-implementations",
    "href": "notebooks/02-benchmark.html#benchmark-single-option-pricing-with-different-r-implementations",
    "title": "Benchmarking American Put option pricing algorithms",
    "section": "1.1 Benchmark single option pricing with different R implementations",
    "text": "1.1 Benchmark single option pricing with different R implementations\n\ns &lt;- 40\nk &lt;- 40\nv &lt;- 0.30\nr &lt;- 0.08\ntt &lt;- 0.25\nd &lt;- 0\nnstep &lt;- 1000\n\nbench_result_one_option_r &lt;- bench::mark(\n  ap_naive(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v1(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v2(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v3(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  min_iterations = 10L\n)\n\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n\nbench_result_one_option_r\n\n# A tibble: 4 × 6\n  expression                             min median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;                           &lt;bch&gt; &lt;bch:&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 ap_naive(S0 = s, K = k, r = r, q = … 212ms  224ms      4.13    23.2MB     14.1\n2 ap_v1(S0 = s, K = k, r = r, q = d, … 152ms  154ms      6.18   276.2KB     20.4\n3 ap_v2(S0 = s, K = k, r = r, q = d, … 152ms  155ms      6.45   263.2KB     20.6\n4 ap_v3(S0 = s, K = k, r = r, q = d, … 151ms  152ms      6.55   760.4KB     21.6",
    "crumbs": [
      "Home",
      "Notebooks",
      "Benchmarking different implementations"
    ]
  },
  {
    "objectID": "notebooks/02-benchmark.html#compute-option-values-for-all-options-in-the-sample",
    "href": "notebooks/02-benchmark.html#compute-option-values-for-all-options-in-the-sample",
    "title": "Benchmarking American Put option pricing algorithms",
    "section": "1.2 Compute option values for all options in the sample",
    "text": "1.2 Compute option values for all options in the sample\nRead the option parameters sample:\n\noption_parameters &lt;- readRDS(here(\"data\", \"processed\", \"option_parameters.rds\"))\n\nComputation time for calculating the option values for all 2500 options in our sample using the naive R implementation:\n\nr_naive_time_all_options &lt;- bench::system_time({\n  option_values_naive &lt;- option_parameters |&gt;\n    mutate(\n      option_value = pmap_dbl(\n        list(\n          S0 = asset_price,\n          K = exercise_price,\n          r = riskless_rate,\n          q = dividend_rate,\n          tt = time_to_maturity,\n          sigma = volatility,\n          steps = nstep\n        ),\n        ap_naive,\n        .progress = FALSE\n      )\n    )\n})\n\nr_naive_time_all_options\n\nprocess    real \n  10.2m   10.1m \n\n\nAnd using the most efficient R implementation (version 3):\n\nr_v3_time_all_options &lt;- bench::system_time({\n  option_values_v3 &lt;- option_parameters |&gt;\n    mutate(\n      option_value = pmap_dbl(\n        list(\n          S0 = asset_price,\n          K = exercise_price,\n          r = riskless_rate,\n          q = dividend_rate,\n          tt = time_to_maturity,\n          sigma = volatility,\n          steps = nstep\n        ),\n        ap_v3,\n        .progress = FALSE\n      )\n    )\n})\n\nr_v3_time_all_options\n\nprocess    real \n  6.72m   6.62m",
    "crumbs": [
      "Home",
      "Notebooks",
      "Benchmarking different implementations"
    ]
  },
  {
    "objectID": "notebooks/02-benchmark.html#parallel-implementation",
    "href": "notebooks/02-benchmark.html#parallel-implementation",
    "title": "Benchmarking American Put option pricing algorithms",
    "section": "1.3 Parallel implementation",
    "text": "1.3 Parallel implementation\nLet’s create new versions of the functions to capture any errors.\n\nap_naive_safe &lt;- safely(ap_naive)\nap_v1_safe &lt;- safely(ap_v1)\nap_v2_safe &lt;- safely(ap_v2)\nap_v3_safe &lt;- safely(ap_v3)\n\nWe can easily parellize the results using the furrr package:\n\nplan(multisession, workers = 10)\nr_v3_par_time_all_options &lt;- bench::system_time({\n  option_values_v3_par &lt;- option_parameters |&gt;\n    mutate(\n      option_value = future_pmap(\n        list(\n          S0 = asset_price,\n          K = exercise_price,\n          r = riskless_rate,\n          q = dividend_rate,\n          tt = time_to_maturity,\n          sigma = volatility,\n          steps = nstep\n        ),\n        ap_v3_safe,\n        .progress = FALSE\n      )\n    ) |&gt;\n    unnest_wider(option_value, names_sep = \"_\")\n})\nr_v3_par_time_all_options\n\nprocess    real \n  1.31s  48.97s \n\nplan(sequential)\n\nstopifnot(all(is.na(option_values_v3_par$option_value_error)))\n\nWe can do the same for version 2 of the algorithm:\n\nplan(multisession, workers = 10)\nr_v2_par_time_all_options &lt;- bench::system_time({\n  option_values_v2_par &lt;- option_parameters |&gt;\n    mutate(\n      option_value = future_pmap(\n        list(\n          S0 = asset_price,\n          K = exercise_price,\n          r = riskless_rate,\n          q = dividend_rate,\n          tt = time_to_maturity,\n          sigma = volatility,\n          steps = nstep\n        ),\n        ap_v2_safe,\n        .progress = FALSE\n      )\n    ) |&gt;\n    unnest_wider(option_value, names_sep = \"_\")\n})\nr_v2_par_time_all_options\n\nprocess    real \n  1.25s  48.99s \n\nplan(sequential)\n\nstopifnot(all(is.na(option_values_v2_par$option_value_error)))\n\nWe can do the same for version 1 of the algorithm:\n\nplan(multisession, workers = 10)\nr_v1_par_time_all_options &lt;- bench::system_time({\n  option_values_v1_par &lt;- option_parameters |&gt;\n    mutate(\n      option_value = future_pmap(\n        list(\n          S0 = asset_price,\n          K = exercise_price,\n          r = riskless_rate,\n          q = dividend_rate,\n          tt = time_to_maturity,\n          sigma = volatility,\n          steps = nstep\n        ),\n        ap_v1_safe,\n        .progress = FALSE\n      )\n    ) |&gt;\n    unnest_wider(option_value, names_sep = \"_\")\n})\nr_v1_par_time_all_options\n\nprocess    real \n  1.26s  49.71s \n\nplan(sequential)\n\nstopifnot(all(is.na(option_values_v1_par$option_value_error)))\n\nAnd finally, we can do the same for the naive implementation of the algorithm:\n\nplan(multisession, workers = 10)\nr_naive_par_time_all_options &lt;- bench::system_time({\n  option_values_naive_par &lt;- option_parameters |&gt;\n    mutate(\n      option_value = future_pmap(\n        list(\n          S0 = asset_price,\n          K = exercise_price,\n          r = riskless_rate,\n          q = dividend_rate,\n          tt = time_to_maturity,\n          sigma = volatility,\n          steps = nstep\n        ),\n        ap_naive_safe,\n        .progress = FALSE\n      )\n    ) |&gt;\n    unnest_wider(option_value, names_sep = \"_\")\n})\nr_naive_par_time_all_options\n\nprocess    real \n  1.69s   1.18m \n\nplan(sequential)\n\nstopifnot(all(is.na(option_values_naive_par$option_value_error)))\n\nThe results are identical across all implementations:\n\nidentical(\n  option_values_naive_par,\n  option_values_v1_par\n)\n\n[1] TRUE\n\nidentical(\n  option_values_v1_par,\n  option_values_v2_par\n)\n\n[1] TRUE\n\nidentical(\n  option_values_v2_par,\n  option_values_v3_par\n)\n\n[1] TRUE",
    "crumbs": [
      "Home",
      "Notebooks",
      "Benchmarking different implementations"
    ]
  },
  {
    "objectID": "notebooks/02-benchmark.html#single-option-benchmark",
    "href": "notebooks/02-benchmark.html#single-option-benchmark",
    "title": "Benchmarking American Put option pricing algorithms",
    "section": "2.1 Single Option Benchmark",
    "text": "2.1 Single Option Benchmark\nLet’s compare the performance of ap_v3 (pure R) with ap_v3_rcpp (C++ core with R wrapper):\n\nbench_result_one_option_rcpp &lt;- bench::mark(\n  ap_v3(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v3_rcpp(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  min_iterations = 10L\n)\n\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n\nbench_result_one_option_rcpp\n\n# A tibble: 2 × 6\n  expression                           min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;                      &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 ap_v3(S0 = s, K = k, r = r, q … 156.69ms 159.58ms      6.25    7.87KB     23.1\n2 ap_v3_rcpp(S0 = s, K = k, r = …   7.95ms   7.98ms    125.    496.13KB      0  \n\n\nVerify that both implementations produce identical results:\n\nstopifnot(all.equal(\n  ap_v3(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v3_rcpp(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep)\n))",
    "crumbs": [
      "Home",
      "Notebooks",
      "Benchmarking different implementations"
    ]
  },
  {
    "objectID": "notebooks/02-benchmark.html#benchmark-on-full-dataset",
    "href": "notebooks/02-benchmark.html#benchmark-on-full-dataset",
    "title": "Benchmarking American Put option pricing algorithms",
    "section": "2.2 Benchmark on full dataset",
    "text": "2.2 Benchmark on full dataset\nNow let’s test the Rcpp implementation on the full dataset of 2,500 options:\n\nrcpp_v3_time_all_options &lt;- bench::system_time({\n  option_values_rcpp &lt;- option_parameters |&gt;\n    mutate(\n      option_value = pmap_dbl(\n        list(\n          S0 = asset_price,\n          K = exercise_price,\n          r = riskless_rate,\n          q = dividend_rate,\n          tt = time_to_maturity,\n          sigma = volatility,\n          steps = nstep\n        ),\n        ap_v3_rcpp,\n        .progress = FALSE\n      )\n    )\n})\n\nrcpp_v3_time_all_options\n\nprocess    real \n  20.5s   20.2s \n\n\nVerify correctness - all implementations should produce identical results:\n\nstopifnot(all.equal(\n  option_values_v3$option_value,\n  option_values_rcpp$option_value,\n  tolerance = 1e-15\n))\n\nWe can also parallelize the Rcpp implementation using the parallel-safe wrapper. Since the Rcpp function creates an external pointer to another object in C++, we can only use it in R session where it was created. So we need to modify the R wrapper function to create the external pointer inside the function. This is what the ap_v3_rcpp_par is doing.\nWe first create a safe version of the Rcpp function:\n\nap_v3_rcpp_par_safe &lt;- safely(ap_v3_rcpp_par)\n\n\nplan(multisession, workers = 10)\nrcpp_v3_par_time_all_options &lt;- bench::system_time({\n  option_values_rcpp_par &lt;- option_parameters |&gt;\n    mutate(\n      option_value = future_pmap(\n        list(\n          S0 = asset_price,\n          K = exercise_price,\n          r = riskless_rate,\n          q = dividend_rate,\n          tt = time_to_maturity,\n          sigma = volatility,\n          steps = nstep\n        ),\n        ap_v3_rcpp_par_safe,\n        .progress = FALSE,\n        .options = furrr_options(seed = TRUE)\n      )\n    ) |&gt;\n    unnest_wider(option_value, names_sep = \"_\")\n})\nrcpp_v3_par_time_all_options\n\n process     real \n388.37ms    7.01s \n\nplan(sequential)\n\nstopifnot(all(is.na(option_values_rcpp_par$option_value_error)))\n\nVerify correctness of parallel implementation:\n\nstopifnot(all.equal(\n  option_values_v3$option_value,\n  option_values_rcpp_par$option_value_result,\n  tolerance = 1e-15\n))",
    "crumbs": [
      "Home",
      "Notebooks",
      "Benchmarking different implementations"
    ]
  },
  {
    "objectID": "notebooks/02-benchmark.html#optimized-parallel-rcpp-using-a-package",
    "href": "notebooks/02-benchmark.html#optimized-parallel-rcpp-using-a-package",
    "title": "Benchmarking American Put option pricing algorithms",
    "section": "2.3 Optimized Parallel Rcpp using a Package",
    "text": "2.3 Optimized Parallel Rcpp using a Package\nThe previous approach (ap_v3_rcpp_par) has overhead because each worker must compile the C++ code on-demand. The best solution is to create a proper R package with pre-compiled code.\nWe created the apopt package which includes: - Pre-compiled C++ code (no runtime compilation needed) - Proper package structure with DESCRIPTION, NAMESPACE - The ap_v3_rcpp() function exported and ready to use\nBenefits of the package approach: 1. No compilation overhead: C++ code is compiled once during package installation 2. Works seamlessly in parallel: Each worker loads the pre-compiled shared library 3. No external pointer issues: The package’s dynamic library is loaded in each worker’s session 4. Reusable: Can be easily shared and installed on other systems\nSince the apopt package exports the same ap_v3_rcpp() function, we can use it directly in parallel without any wrapper:\n\nplan(multisession, workers = 10)\n\n# Benchmark using the apopt package\n# Workers load the pre-compiled package - no compilation overhead!\nrcpp_v3_par_time_all_options_pkg &lt;- bench::system_time({\n  option_values_rcpp_par_pkg &lt;- option_parameters |&gt;\n    mutate(\n      option_value = future_pmap(\n        list(\n          S0 = asset_price,\n          K = exercise_price,\n          r = riskless_rate,\n          q = dividend_rate,\n          tt = time_to_maturity,\n          sigma = volatility,\n          steps = nstep\n        ),\n        safely(apopt::ap_v3_rcpp), # Using the package version\n        .progress = FALSE,\n        .options = furrr_options(seed = TRUE)\n      )\n    ) |&gt;\n    unnest_wider(option_value, names_sep = \"_\")\n})\nrcpp_v3_par_time_all_options_pkg\n\nprocess    real \n175.8ms    2.9s \n\nplan(sequential)\n\nVerify correctness:\n\nstopifnot(all.equal(\n  option_values_v3$option_value,\n  option_values_rcpp_par_pkg$option_value_result,\n  tolerance = 1e-15\n))\n\nCompare the three Rcpp parallel approaches:\n\ntibble(\n  approach = c(\"On-demand per-call compilation\", \"Using pre-compiled package\"),\n  time = c(\n    as.numeric(rcpp_v3_par_time_all_options[\"real\"]),\n    as.numeric(rcpp_v3_par_time_all_options_pkg[\"real\"])\n  )\n) |&gt;\n  mutate(\n    speedup = time[1] / time,\n    time_str = format(bench::as_bench_time(time))\n  )\n\n# A tibble: 2 × 4\n  approach                        time speedup time_str\n  &lt;chr&gt;                          &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;   \n1 On-demand per-call compilation  7.01    1    7.01s   \n2 Using pre-compiled package      2.90    2.42 2.9s",
    "crumbs": [
      "Home",
      "Notebooks",
      "Benchmarking different implementations"
    ]
  },
  {
    "objectID": "notebooks/02-benchmark.html#single-option-benchmark-1",
    "href": "notebooks/02-benchmark.html#single-option-benchmark-1",
    "title": "Benchmarking American Put option pricing algorithms",
    "section": "3.1 Single Option Benchmark",
    "text": "3.1 Single Option Benchmark\n\nbench_result_one_option_julia &lt;- bench::mark(\n  ap_v3(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v3_rcpp(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v3_julia(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  min_iterations = 10L\n)\n\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n\nbench_result_one_option_julia\n\n# A tibble: 3 × 6\n  expression                           min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;                      &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 ap_v3(S0 = s, K = k, r = r, q …  155.7ms 157.82ms      6.35    7.87KB     24.1\n2 ap_v3_rcpp(S0 = s, K = k, r = …   7.95ms   7.98ms    125.      7.87KB      0  \n3 ap_v3_julia(S0 = s, K = k, r =…  10.32ms  10.36ms     95.7     4.26KB      0  \n\n\nVerify that both implementations produce identical results:\n\nstopifnot(all.equal(\n  ap_v3(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v3_julia(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep)\n))",
    "crumbs": [
      "Home",
      "Notebooks",
      "Benchmarking different implementations"
    ]
  },
  {
    "objectID": "notebooks/02-benchmark.html#benchmark-on-full-dataset-1",
    "href": "notebooks/02-benchmark.html#benchmark-on-full-dataset-1",
    "title": "Benchmarking American Put option pricing algorithms",
    "section": "3.2 Benchmark on Full Dataset",
    "text": "3.2 Benchmark on Full Dataset\nNow let’s test the Rcpp implementation on the full dataset of 2,500 options:\n\njulia_v3_time_all_options &lt;- bench::system_time({\n  option_values_julia &lt;- option_parameters |&gt;\n    mutate(\n      option_value = pmap_dbl(\n        list(\n          S0 = asset_price,\n          K = exercise_price,\n          r = riskless_rate,\n          q = dividend_rate,\n          tt = time_to_maturity,\n          sigma = volatility,\n          steps = nstep\n        ),\n        ap_v3_julia,\n        .progress = FALSE\n      )\n    )\n})\n\njulia_v3_time_all_options\n\nprocess    real \n  26.6s   26.2s \n\n\nVerify correctness - all implementations should produce identical results:\n\nstopifnot(all.equal(\n  option_values_v3$option_value,\n  option_values_julia$option_value,\n  tolerance = 1e-13\n))\n\nWe can also parallelize the Julia implementation using the parallel-safe wrapper. Since the Julia function creates an external pointer to another object in Julia, we can only use it in R session where it was created. So we need to use the ap_v3_julia_auto function initializes Julia if necessary and calls the option valuation function in Julia.\nWe first create a safe version of this Julia function:\n\nap_v3_julia_auto_safe &lt;- safely(ap_v3_julia_auto)\n\n\nplan(multisession, workers = 10)\njulia_v3_par_time_all_options &lt;- bench::system_time({\n  option_values_julia_par &lt;- option_parameters |&gt;\n    mutate(\n      option_value = future_pmap(\n        list(\n          S0 = asset_price,\n          K = exercise_price,\n          r = riskless_rate,\n          q = dividend_rate,\n          tt = time_to_maturity,\n          sigma = volatility,\n          steps = nstep\n        ),\n        ap_v3_julia_auto_safe,\n        .progress = FALSE,\n        .options = furrr_options(seed = TRUE)\n      )\n    ) |&gt;\n    unnest_wider(option_value, names_sep = \"_\")\n})\n\nJulia version 1.11.5 at location /Users/nareal/.julia/juliaup/julia-1.11.5+0.aarch64.apple.darwin14/bin will be used.\n\n\nLoading setup script for JuliaCall...\n\n\nFinish loading setup script for JuliaCall.\n\n\nhere() starts at /Users/nareal/Documents/work/uminho/aulas/2025-2026/bp/bplim_workshop_2025\n\n\nJulia initialized with 8 threads and ap_v3.jl loaded successfully\n\n\nJulia version 1.11.5 at location /Users/nareal/.julia/juliaup/julia-1.11.5+0.aarch64.apple.darwin14/bin will be used.\n\n\nLoading setup script for JuliaCall...\n\n\nFinish loading setup script for JuliaCall.\n\n\nhere() starts at /Users/nareal/Documents/work/uminho/aulas/2025-2026/bp/bplim_workshop_2025\n\n\nJulia initialized with 8 threads and ap_v3.jl loaded successfully\n\n\nJulia version 1.11.5 at location /Users/nareal/.julia/juliaup/julia-1.11.5+0.aarch64.apple.darwin14/bin will be used.\n\n\nLoading setup script for JuliaCall...\n\n\nFinish loading setup script for JuliaCall.\n\n\nhere() starts at /Users/nareal/Documents/work/uminho/aulas/2025-2026/bp/bplim_workshop_2025\n\n\nJulia initialized with 8 threads and ap_v3.jl loaded successfully\n\n\nJulia version 1.11.5 at location /Users/nareal/.julia/juliaup/julia-1.11.5+0.aarch64.apple.darwin14/bin will be used.\n\n\nLoading setup script for JuliaCall...\n\n\nFinish loading setup script for JuliaCall.\n\n\nhere() starts at /Users/nareal/Documents/work/uminho/aulas/2025-2026/bp/bplim_workshop_2025\n\n\nJulia initialized with 8 threads and ap_v3.jl loaded successfully\n\n\nJulia version 1.11.5 at location /Users/nareal/.julia/juliaup/julia-1.11.5+0.aarch64.apple.darwin14/bin will be used.\n\n\nLoading setup script for JuliaCall...\n\n\nFinish loading setup script for JuliaCall.\n\n\nhere() starts at /Users/nareal/Documents/work/uminho/aulas/2025-2026/bp/bplim_workshop_2025\n\n\nJulia initialized with 8 threads and ap_v3.jl loaded successfully\n\n\nJulia version 1.11.5 at location /Users/nareal/.julia/juliaup/julia-1.11.5+0.aarch64.apple.darwin14/bin will be used.\n\n\nLoading setup script for JuliaCall...\n\n\nFinish loading setup script for JuliaCall.\n\n\nhere() starts at /Users/nareal/Documents/work/uminho/aulas/2025-2026/bp/bplim_workshop_2025\n\n\nJulia initialized with 8 threads and ap_v3.jl loaded successfully\n\n\nJulia version 1.11.5 at location /Users/nareal/.julia/juliaup/julia-1.11.5+0.aarch64.apple.darwin14/bin will be used.\n\n\nLoading setup script for JuliaCall...\n\n\nFinish loading setup script for JuliaCall.\n\n\nhere() starts at /Users/nareal/Documents/work/uminho/aulas/2025-2026/bp/bplim_workshop_2025\n\n\nJulia initialized with 8 threads and ap_v3.jl loaded successfully\n\n\nJulia version 1.11.5 at location /Users/nareal/.julia/juliaup/julia-1.11.5+0.aarch64.apple.darwin14/bin will be used.\n\n\nLoading setup script for JuliaCall...\n\n\nFinish loading setup script for JuliaCall.\n\n\nhere() starts at /Users/nareal/Documents/work/uminho/aulas/2025-2026/bp/bplim_workshop_2025\n\n\nJulia initialized with 8 threads and ap_v3.jl loaded successfully\n\n\nJulia version 1.11.5 at location /Users/nareal/.julia/juliaup/julia-1.11.5+0.aarch64.apple.darwin14/bin will be used.\n\n\nLoading setup script for JuliaCall...\n\n\nFinish loading setup script for JuliaCall.\n\n\nhere() starts at /Users/nareal/Documents/work/uminho/aulas/2025-2026/bp/bplim_workshop_2025\n\n\nJulia initialized with 8 threads and ap_v3.jl loaded successfully\n\n\nJulia version 1.11.5 at location /Users/nareal/.julia/juliaup/julia-1.11.5+0.aarch64.apple.darwin14/bin will be used.\n\n\nLoading setup script for JuliaCall...\n\n\nFinish loading setup script for JuliaCall.\n\n\nhere() starts at /Users/nareal/Documents/work/uminho/aulas/2025-2026/bp/bplim_workshop_2025\n\n\nJulia initialized with 8 threads and ap_v3.jl loaded successfully\n\njulia_v3_par_time_all_options\n\nprocess    real \n670.8ms   11.7s \n\nplan(sequential)\n\nstopifnot(all(is.na(option_values_julia_par$option_value_error)))\n\nVerify correctness of parallel implementation:\n\nstopifnot(all.equal(\n  option_values_v3$option_value,\n  option_values_julia_par$option_value_result,\n  tolerance = 1e-13\n))",
    "crumbs": [
      "Home",
      "Notebooks",
      "Benchmarking different implementations"
    ]
  },
  {
    "objectID": "notebooks/02-benchmark.html#batch-processing-with-julia-side-parallelization",
    "href": "notebooks/02-benchmark.html#batch-processing-with-julia-side-parallelization",
    "title": "Benchmarking American Put option pricing algorithms",
    "section": "3.3 Batch Processing with Julia-side parallelization",
    "text": "3.3 Batch Processing with Julia-side parallelization\nThe previous parallel approach has significant overhead because each R worker initializes its own Julia runtime. A much more efficient approach is to send all parameters to Julia at once and use Julia’s native multi-threading.\nFirst, let’s reinitialize Julia with a specific number of threads (we’ll use 10 threads):\n\n# Reinitialize Julia with 10 threads\ninit_julia_ap(num_threads = 10)\n\nJulia initialized with 8 threads and ap_v3.jl loaded successfully\n\n\nNow benchmark the batch processing approach:\n\njulia_v3_batch_time_all_options &lt;- bench::system_time({\n  option_values_julia_batch &lt;- option_parameters |&gt;\n    mutate(\n      option_value = ap_v3_julia_batch(\n        S0 = asset_price,\n        K = exercise_price,\n        r = riskless_rate,\n        q = dividend_rate,\n        tt = time_to_maturity,\n        sigma = volatility,\n        steps = nstep\n      )\n    )\n})\n\njulia_v3_batch_time_all_options\n\nprocess    real \n 27.81s   3.54s \n\n\nVerify correctness:\n\nstopifnot(all.equal(\n  option_values_v3$option_value,\n  option_values_julia_batch$option_value,\n  tolerance = 1e-13\n))\n\nThis batch approach should be significantly faster than the R-side parallel approach (julia_v3_par_time_all_options) because: - Single Julia runtime initialization (no overhead per worker) - One bulk data transfer instead of many small transfers - Julia’s efficient native threading via Threads.@threads",
    "crumbs": [
      "Home",
      "Notebooks",
      "Benchmarking different implementations"
    ]
  },
  {
    "objectID": "notebooks/02-benchmark.html#single-option-benchmark-2",
    "href": "notebooks/02-benchmark.html#single-option-benchmark-2",
    "title": "Benchmarking American Put option pricing algorithms",
    "section": "4.1 Single Option Benchmark",
    "text": "4.1 Single Option Benchmark\nFirst, let’s verify that a single option (as a batch of 1) produces the correct result:\n\nbench_result_one_option_torch &lt;- bench::mark(\n  ap_v3(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v3_rcpp(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v3_julia(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v3_torch(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  min_iterations = 10L,\n  check = FALSE\n)\n\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\n\n\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n\nbench_result_one_option_torch\n\n# A tibble: 4 × 6\n  expression                           min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;                      &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 ap_v3(S0 = s, K = k, r = r, q … 162.01ms 168.62ms      5.95    7.87KB     23.8\n2 ap_v3_rcpp(S0 = s, K = k, r = …   7.96ms   8.23ms    121.      7.87KB      0  \n3 ap_v3_julia(S0 = s, K = k, r =…   10.3ms   10.6ms     93.2         0B      0  \n4 ap_v3_torch(S0 = s, K = k, r =… 515.32ms 614.36ms      1.68    1.04MB     11.9\n\n\nVerify correctness:\n\nstopifnot(all.equal(\n  ap_v3(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  ap_v3_torch(S0 = s, K = k, r = r, q = d, tt = tt, sigma = v, steps = nstep),\n  tolerance = 1e-4\n))\n\nMPS device detected. Using torch_float() (float32).\n\n\nNote that on my mac the GPU uses 32-bit floats by default which limits precision, so the results are only equal up to 4 significant digits.",
    "crumbs": [
      "Home",
      "Notebooks",
      "Benchmarking different implementations"
    ]
  },
  {
    "objectID": "notebooks/02-benchmark.html#benchmark-on-full-dataset-with-batching",
    "href": "notebooks/02-benchmark.html#benchmark-on-full-dataset-with-batching",
    "title": "Benchmarking American Put option pricing algorithms",
    "section": "4.2 Benchmark on Full Dataset with Batching",
    "text": "4.2 Benchmark on Full Dataset with Batching\nThe torch implementation is designed to process multiple options simultaneously on the GPU. We’ll group our 2,500 options into batches and process each batch in a single GPU call.\nFirst, let’s create a helper function to process batches:\n\nprocess_torch_batches &lt;- function(data, batch_size, nstep) {\n  # Add batch ID\n  data_with_batches &lt;- data |&gt;\n    mutate(batch_id = ceiling(row_number() / batch_size))\n\n  # Process each batch\n  results &lt;- data_with_batches |&gt;\n    group_by(batch_id) |&gt;\n    nest() |&gt;\n    mutate(\n      option_value = map(data, function(batch_data) {\n        ap_v3_torch(\n          S0 = batch_data$asset_price,\n          K = batch_data$exercise_price,\n          r = batch_data$riskless_rate,\n          q = batch_data$dividend_rate,\n          tt = batch_data$time_to_maturity,\n          sigma = batch_data$volatility,\n          steps = nstep\n        )\n      })\n    ) |&gt;\n    unnest(c(data, option_value))\n\n  return(results)\n}\n\nNow benchmark with different batch sizes:\n\n# Batch size = 100 (25 batches)\ntorch_v3_time_batch_100 &lt;- bench::system_time({\n  option_values_torch_100 &lt;- process_torch_batches(\n    option_parameters,\n    batch_size = 100,\n    nstep = nstep\n  )\n})\n\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\n\ntorch_v3_time_batch_100\n\nprocess    real \n  33.6s   32.6s \n\n\n\n# Batch size = 500 (5 batches)\ntorch_v3_time_batch_500 &lt;- bench::system_time({\n  option_values_torch_500 &lt;- process_torch_batches(\n    option_parameters,\n    batch_size = 500,\n    nstep = nstep\n  )\n})\n\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\nMPS device detected. Using torch_float() (float32).\n\ntorch_v3_time_batch_500\n\nprocess    real \n  24.4s   24.1s \n\n\nVerify correctness - all implementations should produce identical results:\n\nstopifnot(all.equal(\n  option_values_v3_par$option_value_result,\n  option_values_torch_100$option_value,\n  tolerance = 1e-4\n))\n\n\nstopifnot(all.equal(\n  option_values_v3_par$option_value_result,\n  option_values_torch_500$option_value,\n  tolerance = 1e-4\n))\n\nThey are only equal up to 4 significant digits due to differences in floating point arithmetic on the GPU. On my mac the GPU uses 32-bit floats by default which limits precision.",
    "crumbs": [
      "Home",
      "Notebooks",
      "Benchmarking different implementations"
    ]
  }
]